---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
---

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees

## Sugar codes
beetCode = "01801"
caneCode = "01802"
beetSugarCode = "23512"
caneSugarCode = "23511.01"
rawSugarCode = "2351"
refinedSugarCode = "23520"
molassesCode = "23540"
bagasseCode = "39140.02"
beetPulpCode = "39140.01"
sugarSyrupCode = "23210.04"

currentCountry = "840"
currentYear = "2011"

# Never use scientific notation.
options(scipen = 100)
# options(digits = 0)

if(Sys.info()[7] == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] == "Golini"){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}

## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancing.R"))
source(paste0(workingDir, "../../Balancing_ML/R/forceBalance.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancingNormal.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(params$productionCode, params$feedCode, params$seedCode,
                params$wasteCode, params$foodCode, params$stockCode,
                params$importCode, params$exportCode, params$foodProcCode)
wheatKeys = c("0111", "23110", "23140.01", "23140.02", "23140.03", "23220.01",
              "23220.02", "23490.02", "23710", "39120.01", "F0020", "F0022")
cattleKeys = c("02111", "21111.01", "21111.02", "21182", "21184.01", "21185",
               "21512.01", "23991.04", "F0875")
palmOilKeys = c("01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120")
sugarKeys = c("01802", "23512", "F7156", "23210.04", "2351", "23511", "23520",
              "23540", "23670.01", "24110", "2413", "24131", "24139",
              "24490.92", "39140.02", "F7157", "01801", "39140.01", "F7161",
              "01809", "F7162", "F7163")
milkKeys = c("02211", "22110.01", "22110.02", "22110.03", "22211", "22212",
             "22221.01", "22221.02", "22222.01", "22222.02", "22230.01",
             "22230.02", "22230.03", "22230.04", "22241.01", "22241.02",
             "22251.01", "22251.02", "22251.03", "2251.04", "22260",
             "23210.06")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
fullData = fullData[timePointYears == currentYear &
                        geographicAreaM49 == currentCountry, ]
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
## Set up empty variable for food processing
foodProcVar = paste0(params$elementPrefix, params$foodProcCode)
fullData[, c(foodProcVar) := NA_real_]
## Set up empty variable for industrial utilization
indVar = paste0(params$elementPrefix, params$industrialCode)
fullData[, c(indVar) := NA_real_]
## Set up empty variable for tourist consumption
touVar = paste0(params$elementPrefix, params$touristCode)
fullData[, c(touVar) := NA_real_]

pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120", "f???")

tree = fread(paste0(workingDir, "standardizationTree.csv"),
             colClasses = c("character", "character", "numeric", "character",
                            "numeric", "character", "numeric"))
## Don't want infinite extraction rates until standardization, so just make up
## some
## Butcher fat to cattle meat
tree[parentID == "21111.01" & childID == "21512.01", extractionRate := 0.05]
## Cake of palm kernels to palm kernels
tree[parentID == "01491.02" & childID == "21910.06", extractionRate := 0.10]
## Gluten to flour
tree[parentID == "23110" & childID == "23220.02", extractionRate := 0.5]
## Conversion to CPC was slightly problematic: Beet sugar gets processed into 
## element "23510" for which we have no data (and the CPC code doesn't seem to 
## exist in the online UN directory: 
## http://unstats.un.org/unsd/cr/registry/docs/CPCv2_structure.pdf.  So, Beet
## sugar and Cane sugar will be processed directly to Refined sugar (for the
## purpose of this example at least).
tree = tree[!parentID == "23510" & !childID == "23510", ]
tree = rbindlist(list(tree,
                      data.table(childID = "23520", target = "B",
                                 extractionRate = 0.92,
                                 parentID = c(23511.01, 23512),
                                 calorieExtractionRate = 1,
                                 groupID = c("23511.01-23520", "23512-23520"))),
                 fill = TRUE)
edges = tree[(parentID %in% sugarKeys | childID %in% sugarKeys) &
                 !is.na(parentID) & !is.na(childID), ]

itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))

## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Sugar

Now, let's consider the full process for creating a food balance sheet for sugar.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = fullData[measuredItemCPC %in% sugarKeys, ]
sugarData = data.table:::melt.data.table(data = sugarData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
sugarData[grepl("Value", variable), variableType := "Value"]
sugarData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
sugarData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = sugarData, formula = as.formula(castFormula),
#                             value.var = "value")
sugarData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(sugarData, "variable", "element")
sugarData = tidyr::spread(data = sugarData, key = "variableType", value = "value")
sugarData[, Value := as.numeric(Value)]
## Remove alot of the data, and "impute" it later
sugarData[element %in% fbsElements, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  In this case, the production value is known for all the primary products and thus no imputation is done.  We also have production data for some of the processed commodities:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = merge(sugarData,
                  fullData[measuredItemCPC %in% sugarKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
sugarData[element == "5510", Value := Value_measuredElement_5510]
## Remove some of the official data to show an example that seems a bit
## different from wheat (i.e. we don't want official figures everywhere).
sugarData[element == "5510" & measuredItemCPC %in% c(molassesCode, beetSugarCode),
          Value := NA]
sugarData[, standardDeviation := 0]
sugarData[element == "5510" & Value == 0, Value := NA]
sugarData[, Value_measuredElement_5510 := NULL]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

For the next example, we'll show how the imputation, mirroring and balancing works.  In this case, we just take the country totals and insert into this table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
# sugarData[element == "5600" & measuredItemCPC == "23140.02" &
#               timePointYears == "2011", Value := 182485]
# sugarData[element == "5900" & measuredItemCPC == "23140.03" &
#               timePointYears == "2011", Value := 217289]
sugarData[element == "5600" & Value == 0, Value := NA]
sugarData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
sugarData = sugarData[geographicAreaM49 == currentCountry, ]
# params$mergeKey = params$mergeKey[2:3]

toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

### Stock Changes

We now estimate the stock changes.  Note that for most products, we assume that countries do not hold stocks.  Generally, stocks will only be held for primary level products, and not even all of these products.  The numbers below represent the estimated stock changes (by the stock imputation methodology described previously) for the example country we're considering.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
sugarData = replaceData(sugarData,
            stockEstimates[, c("Value_measuredElement_71",
                               "standardDeviation_measuredElement_71",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[is.na(Value) & element == "71", Value := 0]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The allocation to food, on the other hand, can potentially be considered at any processing level, although some commodities (such as wheat) are assumed to not be eaten as such.  We impute food consumption numbers for the example country and update the FBS table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[is.na(share), share := 1]
## Hack the tree a bit.  Roll up refined sugar into raw sugar (2351)
standTree = standTree[!childID %in% c(refinedSugarCode), ]
standTree = rbind(standTree, data.table(childID = "23520", target = "B",
                                        extractionRate = 0.92,
                                        parentID = rawSugarCode,
                                        calorieExtractionRate = 1,
                                        groupID = "2351-23520",
                                        share = 1, geographicAreaM49 = "840",
                                        timePointYears = "2011"))
## Also have to add this commodity to sugarData
sugarData = rbind(sugarData, data.table(geographicAreaM49 = "840",
                                        timePointYears = "2011",
                                        measuredItemCPC = rawSugarCode,
                                        element = sugarData[, unique(element)],
                                        metFlag = NA, obsFlag = NA,
                                        Value = NA, standardDeviation = 0))
foodEstimates = standardizeTree(data = foodEstimates, tree = standTree,
                                elements = "5141", standParams = params,
                                sugarHack = FALSE)
foodEstimates[, standardDeviation_measuredElement_5141 := .1 * Value_measuredElement_5141]
sugarData = replaceData(sugarData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# sugarData[element == "5141" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141"]
printTable(toPrint, params, workingDir)
})})
```

### Feed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "feedEstimates.RData"))
feedEstimates[, standardDeviation_measuredElement_5520 :=
                  Value_measuredElement_5520 * .1]
sugarData = replaceData(sugarData,
            feedEstimates[, c("Value_measuredElement_5520",
                               "standardDeviation_measuredElement_5520",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5520" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
sugarData = replaceData(sugarData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5120" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  Value_measuredElement_5525 * .1]
sugarData = replaceData(sugarData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5525" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
sugarData = replaceData(sugarData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "i???" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the WTO as well as last year's consumption patterns to estimate the impact of tourism on local consumption.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, the country will have a negative ``tourist consumption'' because more calories will be assumed abroad than locally.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates = standardizeTree(data = touristEstimates, tree = standTree,
                                   elements = "tou", standParams = params,
                                   sugarHack = FALSE)
touristEstimates[measuredItemCPC %in% c(caneCode, beetCode),
                 Value_measuredElement_tou := NA]
touristEstimates[, standardDeviation_measuredElement_tou := 
                     1 * Value_measuredElement_tou]
setnames(touristEstimates, old = "Value_measuredElement_tou",
         new = "Value_measuredElement_t???")
setnames(touristEstimates, old = "standardDeviation_measuredElement_tou",
         new = "standardDeviation_measuredElement_t???")
sugarData = replaceData(sugarData,
            touristEstimates[, c("Value_measuredElement_t???",
                               "standardDeviation_measuredElement_t???",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# sugarData[element == "5141" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141"]
printTable(toPrint, params, workingDir)
})})
```

### Standardization and Balancing

Now, suppose we have the following commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
edges = tree[childID %in% sugarKeys | parentID %in% sugarKeys, ]
itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))
setnames(itemName, "Item", params$parentVar)
edges = merge(edges, itemName, by = params$parentVar, all.x = TRUE)
edges[, c("parentID", "Name") := list(Name, NULL)]
setnames(itemName, params$parentVar, params$childVar)
edges = merge(edges, itemName, by = params$childVar, all.x = TRUE)
edges[, c("childID", "Name") := list(Name, NULL)]
edges[, childID := gsub(" ", "\n", childID)]
edges[, parentID := gsub(" ", "\n", parentID)]
plotSingleTree(edges = edges,
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .06,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

Note that in this commodity tree, we create cane sugar and beet sugar from sugar cane and sugar beet, respectively, and then both of these raw sugars are processed into refined sugar.  In order to simplify reporting, cane sugar and beet sugar are grouped together into one commodity "Raw cane or beet sugar."

```{r, echo = FALSE}
# save(sugarData, tree, file = paste0(workingDir, "preStandardizedSugar.RData"))
# load(paste0(workingDir, "preStandardizedSugar.RData"))
suppressWarnings({suppressMessages({
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

The processing for sugar works slightly differently than most commodities.  Sugar cane and sugar beet are, in almost every case, converted into cane sugar or beet sugar (i.e. they are not eaten as such nor are they processed into other products).  Thus, in this case, rather than standardizing values back to sugar cane and sugar beet, we instead assume all sugar cane and sugar beet is first converted into the corresponding sugar and we perform the balances at this level.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
tree[parentID == beetCode & childID == beetSugarCode, childID := rawSugarCode]
tree[parentID == caneCode & childID == caneSugarCode, childID := rawSugarCode]
output = processForward(sugarData, tree, standParams = params)
sugarData = output$data
sugarData[measuredItemCPC %in% c(beetSugarCode, caneSugarCode),
          measuredItemCPC := rawSugarCode]
## Use the mode as the flag aggregation algorithm
Mode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
}
sugarData = sugarData[, list(metFlag = Mode(metFlag),
                             obsFlag = Mode(obsFlag),
                             Value = sum(Value, na.rm = TRUE),
                             standardDeviation = sqrt(sum(standardDeviation^2, na.rm = TRUE))),
                      by = c(params$mergeKey, "element")]
tree = output$tree
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[element == params$productionCode &
            get(params$itemVar) %in% c(caneSugarCode, bagasseCode, rawSugarCode,
                                       beetPulpCode, molassesCode),
        updateFlag := TRUE]
printTable(toPrint, params, workingDir)
})})
```

The next step in this process is to balance the processed commodities by creating production values.  However, we do not have any trade deficits, and thus we do not need to worry about this step.

```{r, echo = FALSE, eval = FALSE}
suppressWarnings({suppressMessages({
computeProcessedProduction(data = sugarData, tree = tree, standParams = params)
sugarData[element == "5510" & Value < 0, Value := 0]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := (element == "5510" & Value < 18000000)]
printTable(toPrint, params, workingDir)
})})
```

```{r, echo = FALSE}
## Now, do all the stuff you did above, plus compute the aggregated standard
## errors, in a more rigorous way:
invisible({suppressWarnings({suppressMessages({
sugarData = rollUpFood(data = sugarData, tree = tree, standParams = params)
sugarData = sugarData[!measuredItemCPC %in% c(caneSugarCode, beetSugarCode), ]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := (element == params$foodProcCode & Value > 0)]
})})})
```

```{r, echo = FALSE, eval = FALSE}
## Set eval to TRUE to verify the two processes give the same result.
printTable(toPrint, params, workingDir)
```

Now, we must balance the primary products in this table (i.e. sugar cane and sugar beet).  To do this, we need to extract the computed standard deviations of each element.  The table below shows the expected value and estimated standard deviation for sugar beet (top) and sugar cane (bottom):

```{r, echo = FALSE}
toPrint = toPrint[measuredItemCPC == rawSugarCode, ]
printDistributionTable(toPrint, params)
```

After balancing the above tables, we're left with the following values.  Note that food processing is the element that receives most of the adjustment because it has a substantially higher variability.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
toPrint = toPrint[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
toPrint[is.na(Value), Value := 0]
toPrint[is.na(standardDeviation), standardDeviation := 0]
sink("temp.txt") # Sink balancing output so it doesn't get printed.
toPrint[, balancedValue := balancing(param1 = Value, param2 = standardDeviation,
          sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
          lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
          optimize = "constrOptim")]
sink()
toPrint[, adjustment := balancedValue - Value]
sugarData = merge(sugarData,
                  toPrint[, c(params$mergeKey, "element", "balancedValue",
                              "adjustment"), with = FALSE],
                  by = c(params$mergeKey, "element"), all.x = TRUE)
sugarData[!is.na(balancedValue), Value := balancedValue]
sugarData[, balancedValue := NULL]
toPrint[, Value := balancedValue]
toPrint[, c("adjustment", "balancedValue") := NULL]
printDistributionTable(toPrint, params)
})})
```

We can now adjust our SUA table with the updated/balanced values:

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
# save(sugarData, tree, file = paste0(workingDir, "standardizedSugar1.RData"))
# load(paste0(workingDir, "standardizedSugar1.RData"))
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := FALSE]
toPrint[measuredItemCPC == caneSugarCode & element %in% c("5510", "f???"),
        updateFlag := TRUE]
toPrint[measuredItemCPC == beetSugarCode & element == "f???",
        updateFlag := TRUE]
printTable(toPrint, params, workingDir)
})})
```

We must now process the changes in the current elements down the tree into the other elements.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
## Allocate down the adjustments in the true/automated way
sink("temp.txt") # Sink balancing output so it doesn't get printed.
sugarData = synchronizeByProducts(data = sugarData, tree = tree,
                                  standParams = params)
sink()
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, adjustment := NULL]
toPrint[, updateFlag := (measuredItemCPC == refinedSugarCode) &
            (element %in% c(params$productionCode, params$stockCode,
                            params$foodCode))]
printTable(toPrint, params, workingDir)
})})
```

Lastly, some elements have not yet been updated in this process.  To ensure a full balance of the SUA, we should go through and balance those rows as well.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
sugarData = rbind(sugarData, data.table(measuredItemCPC = beetPulpCode,
                                        element = params$feedCode,
                                        geographicAreaM49 = "840",
                                        timePointYears = "2011",
                                        metFlag = NA,
                                        obsFlag = NA,
                                        Value = NA,
                                        standardDeviation = NA,
                                        adjustment = NA))
sugarData = rbind(sugarData, data.table(measuredItemCPC = bagasseCode,
                                        element = params$industrialCode,
                                        geographicAreaM49 = "840",
                                        timePointYears = "2011",
                                        metFlag = NA,
                                        obsFlag = NA,
                                        Value = NA,
                                        standardDeviation = NA,
                                        adjustment = NA))
finalSuaBalance(sugarData, standParams = params,
                feedElements = c(molassesCode, beetPulpCode),
                indElements = bagasseCode)
toPrint = sugarData[timePointYears == "2011", ]
toPrint[, updateFlag := element == params$foodCode &
            measuredItemCPC %in% c(sugarSyrupCode)]
printTable(toPrint, params, workingDir)
})})
```

Now, we standardize all these commodities into their primary equivalents: raw sugar.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
params$elementPrefix = ""
invisible({
## Don't standardize back bagasse, beet pulp, or molasses
standTree = standTree[!parentID %in% c("01801", "01802"), ]
standTree[childID %in% c(bagasseCode, beetPulpCode, molassesCode),
          extractionRate := Inf]
})
standTree[parentID == beetSugarCode & childID == refinedSugarCode,
          share := c(as.numeric(gsub("%", "",
                        splitRatio$Percent[splitRatio$Name == "Beet sugar"]))/100)]
standTree[parentID == caneSugarCode & childID == refinedSugarCode,
          share := c(as.numeric(gsub("%", "",
                        splitRatio$Percent[splitRatio$Name == "Cane sugar, centrifugal"]))/100)]
params$elementPrefix = ""
finalValues = finalStandardizationToPrimary(data = sugarData, tree = standTree,
                                            standParams = params,
                                            sugarHack = FALSE)
finalValues = finalValues[timePointYears == "2011" &
    get(params$itemVar) == rawSugarCode, ]
printTable(finalValues, standParams = params, workingDir)
})})
```

We can also compute calories, fats, and proteins at this point.  First, we apply a calorie/fat/protein content factor to each individual element:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

load(paste0(workingDir, "nutrientData.RData"))
# Loads object "nutrientData"
    
toPrint = sugarData[timePointYears == "2011" & element == params$foodCode, ]
toPrint = merge(toPrint, nutrientData, by = params$itemVar, all.x = TRUE)
toPrint[measuredItemCPC == rawSugarCode & element == "5141", Value := 0]

## Don't print some elements
skippedElements = c(24110, 2413, 23210.05, 24490.92, molassesCode)
toPrint = toPrint[!get(params$itemVar) %in% skippedElements, ]

setnames(itemName, params$childVar, params$itemVar)
toPrint = merge(toPrint[, c(params$itemVar, "Value", "Protein", "Fat", "Energy"),
                        with = FALSE], itemName, all.x = TRUE)
setnames(itemName, params$itemVar, "Item")
toPrint[, measuredItemCPC := NULL]

setcolorder(toPrint, c("Name", "Value", "Energy", "Protein", "Fat"))
setnames(toPrint, "Value", "Quantity")
toPrintCopy = copy(toPrint)
toPrint[, Quantity := sapply(Quantity, roundNum)]
toPrint[, Energy := round(Energy, 0)]
toPrint[, Protein := round(Protein, 2)]
toPrint[, Fat := round(Fat, 2)]
knitr::kable(toPrint, align = c("l", "r", "r", "r", "r"))
})})
```

Standardization of calories is simpler since we don't need to divide by extraction rates: the standardized calories/fats/proteins are the sum of the total calories/fats/proteins for each element.  However, this is more complicated than simply adding up calories/fats/proteins because we have to standardize children commodities into multiple parents.  For example, as with the quantity standardization, we should standardize refined sugar back into cane sugar and beet sugar according to the proportion from processing:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
out = toPrintCopy[, list(
    Energy  = sum(Quantity * Energy , na.rm = TRUE)/1000000,
    Protein = sum(Quantity * Protein, na.rm = TRUE)/1000000,
    Fat     = sum(Quantity * Fat    , na.rm = TRUE)/1000000), by = ""]
out[, Energy := round(Energy/100, 0)*100]
out[, Protein := round(Protein, 0)]
out[, Fat := round(Fat, 0)]
setnames(out, colnames(out), paste(colnames(out), "(millions)"))
out = cbind(data.table(Commodity = "Raw Sugar Equivalent"), out)
knitr::kable(out, align = c("l", "r", "r", "r"))
})})
```