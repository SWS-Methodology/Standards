---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
---

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees

## Sugar codes
beetCode = "01801"
caneCode = "01802"
beetSugarCode = "23512"
caneSugarCode = "23511.01"
refinedSugarCode = "23520"
molassesCode = "23540"
bagasseCode = "39140.02"
beetPulpCode = "39140.01"
sugarSyrupCode = "23210.04"

currentCountry = "840"
currentYear = "2011"

# Never use scientific notation.
options(scipen = 100)
# options(digits = 0)

if(Sys.info()[7] == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] == "Golini"){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}

## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancing.R"))
source(paste0(workingDir, "../../Balancing_ML/R/forceBalance.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancingNormal.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(params$productionCode, params$feedCode, params$seedCode,
                params$wasteCode, params$foodCode, params$stockCode,
                params$importCode, params$exportCode, params$foodProcCode)
wheatKeys = c("0111", "23110", "23140.01", "23140.02", "23140.03", "23220.01",
              "23220.02", "23490.02", "23710", "39120.01", "F0020", "F0022")
cattleKeys = c("02111", "21111.01", "21111.02", "21182", "21184.01", "21185",
               "21512.01", "23991.04", "F0875")
palmOilKeys = c("01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120")
sugarKeys = c("01802", "23512", "F7156", "23210.04", "2351", "23511", "23520",
              "23540", "23670.01", "24110", "2413", "24131", "24139",
              "24490.92", "39140.02", "F7157", "01801", "39140.01", "F7161",
              "01809", "F7162", "F7163")
milkKeys = c("02211", "22110.01", "22110.02", "22110.03", "22211", "22212",
             "22221.01", "22221.02", "22222.01", "22222.02", "22230.01",
             "22230.02", "22230.03", "22230.04", "22241.01", "22241.02",
             "22251.01", "22251.02", "22251.03", "2251.04", "22260",
             "23210.06")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
fullData = fullData[timePointYears == currentYear &
                        geographicAreaM49 == currentCountry, ]
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
## Set up empty variable for food processing
foodProcVar = paste0(params$elementPrefix, params$foodProcCode)
fullData[, c(foodProcVar) := NA_real_]
## Set up empty variable for industrial utilization
indVar = paste0(params$elementPrefix, params$industrialCode)
fullData[, c(indVar) := NA_real_]
## Set up empty variable for tourist consumption
touVar = paste0(params$elementPrefix, params$touristCode)
fullData[, c(touVar) := NA_real_]

pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120", "f???")

tree = fread(paste0(workingDir, "standardizationTree.csv"),
             colClasses = c("character", "character", "numeric", "character",
                            "numeric", "character", "numeric"))
## Don't want infinite extraction rates until standardization, so just make up
## some
## Butcher fat to cattle meat
tree[parentID == "21111.01" & childID == "21512.01", extractionRate := 0.05]
## Cake of palm kernels to palm kernels
tree[parentID == "01491.02" & childID == "21910.06", extractionRate := 0.10]
## Gluten to flour
tree[parentID == "23110" & childID == "23220.02", extractionRate := 0.5]
## Conversion to CPC was slightly problematic: Beet sugar gets processed into 
## element "23510" for which we have no data (and the CPC code doesn't seem to 
## exist in the online UN directory: 
## http://unstats.un.org/unsd/cr/registry/docs/CPCv2_structure.pdf.  So, Beet
## sugar and Cane sugar will be processed directly to Refined sugar (for the
## purpose of this example at least).
tree = tree[!parentID == "23510" & !childID == "23510", ]
tree = rbindlist(list(tree,
                      data.table(childID = "23520", target = "B",
                                 extractionRate = 0.92,
                                 parentID = c(23511.01, 23512),
                                 calorieExtractionRate = 1,
                                 groupID = c("23511.01-23520", "23512-23520"))),
                 fill = TRUE)
edges = tree[(parentID %in% sugarKeys | childID %in% sugarKeys) &
                 !is.na(parentID) & !is.na(childID), ]

itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))

## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Sugar

Now, let's consider the full process for creating a food balance sheet for sugar.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = fullData[measuredItemCPC %in% sugarKeys, ]
sugarData = data.table:::melt.data.table(data = sugarData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
sugarData[grepl("Value", variable), variableType := "Value"]
sugarData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
sugarData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = sugarData, formula = as.formula(castFormula),
#                             value.var = "value")
sugarData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(sugarData, "variable", "element")
sugarData = tidyr::spread(data = sugarData, key = "variableType", value = "value")
## Remove alot of the data, and "impute" it later
sugarData[, Value := rep(0, nrow(sugarData))]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  In this case, the production value is known for all the primary products and thus no imputation is done.  We also have production data for some of the processed commodities:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = merge(sugarData,
                  fullData[measuredItemCPC %in% sugarKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
sugarData[element == "5510", Value := Value_measuredElement_5510]
sugarData[, standardDeviation := 0]
sugarData[element == "5510" & Value == 0, Value := NA]
sugarData[, Value_measuredElement_5510 := NULL]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

For the next example, we'll show how the imputation, mirroring and balancing works.  In this case, we just take the country totals and insert into this table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
# sugarData[element == "5600" & measuredItemCPC == "23140.02" &
#               timePointYears == "2011", Value := 182485]
# sugarData[element == "5900" & measuredItemCPC == "23140.03" &
#               timePointYears == "2011", Value := 217289]
sugarData[element == "5600" & Value == 0, Value := NA]
sugarData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
sugarData = sugarData[geographicAreaM49 == currentCountry, ]
# params$mergeKey = params$mergeKey[2:3]

toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

### Stock Changes

We now estimate the stock changes.  Note that for most products, we assume that countries do not hold stocks.  Generally, stocks will only be held for primary level products, and not even all of these products.  The numbers below represent the estimated stock changes (by the stock imputation methodology described previously) for the example country we're considering.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
sugarData = replaceData(sugarData,
            stockEstimates[, c("Value_measuredElement_71",
                               "standardDeviation_measuredElement_71",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "71" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The allocation to food, on the other hand, can potentially be considered at any processing level, although some commodities (such as wheat) are assumed to not be eaten as such.  We impute food consumption numbers for the example country and update the FBS table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
## Balance is impossible if food variance is 0:
foodEstimates[measuredItemCPC == refinedSugarCode,
              standardDeviation_measuredElement_5141 := 880000]
sugarData = replaceData(sugarData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# sugarData[element == "5141" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141" & Value > 0]
printTable(toPrint, params, workingDir)
})})
```

### Feed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "feedEstimates.RData"))
feedEstimates[, standardDeviation_measuredElement_5520 :=
                  Value_measuredElement_5520 * .1]
sugarData = replaceData(sugarData,
            feedEstimates[, c("Value_measuredElement_5520",
                               "standardDeviation_measuredElement_5520",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5520" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
sugarData = replaceData(sugarData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5120" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  Value_measuredElement_5525 * .1]
sugarData = replaceData(sugarData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5525" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
sugarData = replaceData(sugarData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "i???" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the WTO as well as last year's consumption patterns to estimate the impact of tourism on local consumption.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, the country will have a negative ``tourist consumption'' because more calories will be assumed abroad than locally.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates[, standardDeviation_measuredElement_tou :=
                     abs(Value_measuredElement_tou) * .1]
setnames(touristEstimates, "Value_measuredElement_tou",
         "Value_measuredElement_t???")
setnames(touristEstimates, "standardDeviation_measuredElement_tou",
         "standardDeviation_measuredElement_t???")
sugarData = replaceData(sugarData,
            touristEstimates[, c("Value_measuredElement_t???",
                                 "standardDeviation_measuredElement_t???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "t???" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "t???"]
printTable(toPrint, params, workingDir)
})})
```

### Standardization and Balancing

Now, suppose we have the following commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
edges = tree[childID %in% sugarKeys | parentID %in% sugarKeys, ]
itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))
setnames(itemName, "Item", params$parentVar)
edges = merge(edges, itemName, by = params$parentVar, all.x = TRUE)
edges[, c("parentID", "Name") := list(Name, NULL)]
setnames(itemName, params$parentVar, params$childVar)
edges = merge(edges, itemName, by = params$childVar, all.x = TRUE)
edges[, c("childID", "Name") := list(Name, NULL)]
edges[, childID := gsub(" ", "\n", childID)]
edges[, parentID := gsub(" ", "\n", parentID)]
plotSingleTree(edges = edges,
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .06,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

We first start with the pre-standardized table:

```{r, echo = FALSE}
# save(sugarData, tree, file = paste0(workingDir, "preStandardizedSugar.RData"))
# load(paste0(workingDir, "preStandardizedSugar.RData"))
suppressWarnings({suppressMessages({
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

The processing for sugar works slightly differently than most commodities.  Sugar cane and sugar beet are, in almost every case, converted into cane sugar or beet sugar (i.e. they are not eaten as such nor are they processed into other products).  Thus, in this case, rather than standardizing values back to sugar cane and sugar beet, we instead assume all sugar cane and sugar beet is first converted into the corresponding sugar and we perform the balances at this level.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
output = processForward(sugarData, tree, standParams = params)
sugarData = output$data
tree = output$tree
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[element == params$productionCode &
            get(params$itemVar) %in% c(caneSugarCode, bagasseCode,
                                              beetPulpCode),
        updateFlag := TRUE]
printTable(toPrint, params, workingDir)
})})
```

The next step in this process is to balance the processed commodities by creating production values.  These production values will require an amount of food processing from the parent commodities.  We must start this process at the bottom of the tree, in this case considering "Sugar and Syrups nes" and "Sugar Confectionary" and going up to "Refined Sugar".  However, the supply for "Sugar and Syrups nes" exceeds the utilization, and we have no data for "Sugar Confectionary", so we don't need to introduce any required production in this step.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
toPrint[, updateFlag := FALSE]
# Manually input the production/food processing values to show the process.
toPrint[, tempProd := sum(Value *
    ifelse(element %in% c(params$exportCode, params$stockCode, params$foodCode,
                          params$foodProcCode, params$feedCode, params$wasteCode,
                          params$seedCode, params$industrialCode, params$touristCode,
                          params$residualCode), 1,
           ifelse(element == params$importCode, -1, 0)), na.rm = TRUE),
    by = c(params$mergeKey)]
toPrint[tempProd < 0, tempProd := 0]
invisible(toPrint[measuredItemCPC == 23210.04 &
            element == params$productionCode,
        c("Value", "updateFlag") := list(tempProd, TRUE)])
invisible(toPrint[measuredItemCPC == 23520 &
            element == params$foodProcCode,
        c("Value", "updateFlag") := list(
            toPrint[measuredItemCPC == 23210.04 &
                        element == params$productionCode, Value], TRUE)])
printTable(toPrint, params, workingDir)
})})
```

Next, we move up the tree to the balancing of refined sugar and the food processing required in the beet and cane sugar elements.  We require refined sugar production in order to balance refined sugar, and thus we must create this production from the parent(s) of refined sugar.  Looking at the commodity tree, we see that refined sugar can be created from both beet and cane sugar.  We will allocate production of refined sugar from these parent commodities according to their availabilities.  Note that the food processing quantities from beet sugar and cane sugar must be multiplied by their corresponding extraction rates to compute the production value of refined sugar.  Moreover, if the extraction rates from these two parents are different, then we must compute availabilities weighted by these extraction rates.  In this case, we could ignore this because the extraction rates are identical.

```{r, echo = FALSE}
splitRatio = data.frame(Name = c("Beet sugar", "Cane sugar, centrifugal"),
                  Availability = c(4561000+9-194806,
                                   2720837),
                  Percent = c(4366203/(4366203+2720837), 2893793/(4366203+2720837)))
splitRatio$Percent = paste0(round(splitRatio$Percent, 3)*100, "%")
knitr::kable(splitRatio, align = c("r", "r", "r"))
```

Thus, we allocate according to the parent availabilities:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

toPrint[, updateFlag := FALSE]
# Manually input the production/food processing values to show the process.
toPrint[, tempProd := sum(Value *
    ifelse(element %in% c(params$exportCode, params$stockCode, params$foodCode,
                          params$foodProcCode, params$feedCode, params$wasteCode,
                          params$seedCode, params$industrialCode, params$touristCode,
                          params$residualCode), 1,
           ifelse(element == params$importCode, -1, 0)), na.rm = TRUE),
    by = c(params$mergeKey)]
invisible(toPrint[measuredItemCPC == 23520 &
            element == params$productionCode,
        c("Value", "updateFlag") := list(tempProd, TRUE)])
invisible(toPrint[measuredItemCPC == beetSugarCode &
            element == params$foodProcCode,
        c("Value", "updateFlag") := list(
            toPrint[measuredItemCPC == 23520 &
                        element == params$productionCode, Value]/.92 * .603, TRUE)])
toAppend = toPrint[1, ]
toAppend[, c(params$itemVar, "element", "Value", "updateFlag") :=
             list(caneSugarCode, params$foodProcCode, 
                  toPrint[measuredItemCPC == 23520 &
                              element == params$productionCode, Value]/.92 * .397,
                  TRUE)]
toPrint = rbind(toPrint, toAppend)
printTable(toPrint, params, workingDir)
})})
```

```{r, echo = FALSE}
## Now, do all the stuff you did above, plus compute the aggregated standard
## errors, in a more rigorous way:
invisible({suppressWarnings({suppressMessages({
sugarData = rollUpFood(data = sugarData, tree = tree, standParams = params)
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := (element == params$foodProcCode & Value > 0)]
})})})
```

```{r, echo = FALSE, eval = FALSE}
## Set eval to TRUE to verify the two processes give the same result.
printTable(toPrint, params, workingDir)
```

Now, we must balance the primary products in this table (i.e. sugar cane and sugar beet).  To do this, we need to extract the computed standard deviations of each element.  The table below shows the expected value and estimated standard deviation for sugar beet (top) and sugar cane (bottom):

```{r, echo = FALSE}
toPrintBeet = toPrint[measuredItemCPC == beetSugarCode, ]
printDistributionTable(toPrintBeet, params)
toPrintCane = toPrint[measuredItemCPC == caneSugarCode, ]
toPrintCane = rbindlist(list(toPrintCane,
        data.table(geographicAreaM49 = 840, timePointYears = 2011,
                   measuredItemCPC = 23511.01,
                   element = c(params$feedCode, params$seedCode,
                               params$wasteCode, params$foodCode,
                               params$stockCode, params$importCode,
                               params$exportCode, params$industrialCode,
                               params$touristCode))), fill = TRUE)
printDistributionTable(toPrintCane, params)
```

After balancing the above tables, we're left with the following values.  Note that food processing is the element that receives most of the adjustment because it has a substantially higher variability.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
toPrintBeet = toPrintBeet[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
toPrintCane = toPrintCane[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
toPrintBeet[is.na(Value), Value := 0]
toPrintCane[is.na(Value), Value := 0]
toPrintBeet[is.na(standardDeviation), standardDeviation := 0]
toPrintCane[is.na(standardDeviation), standardDeviation := 0]
sink("temp.txt") # Sink balancing output so it doesn't get printed.
toPrintBeet[, balancedValue := balancing(param1 = Value, param2 = standardDeviation,
          sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
          lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
          optimize = "constrOptim")]
toPrintCane[, balancedValue := balancing(param1 = Value, param2 = standardDeviation,
          sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
          lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
          optimize = "constrOptim")]
sink()
toPrintBeet[, adjustment := balancedValue - Value]
toPrintCane[, adjustment := balancedValue - Value]
sugarData = merge(sugarData,
                  rbind(toPrintBeet, toPrintCane)[, c(params$mergeKey, "element",
                                                      "balancedValue", "adjustment"),
                                                  with = FALSE],
                  by = c(params$mergeKey, "element"), all.x = TRUE)
sugarData[!is.na(balancedValue), Value := balancedValue]
sugarData[, balancedValue := NULL]
toPrintBeet[, Value := balancedValue]
toPrintCane[, Value := balancedValue]
toPrintBeet[, c("adjustment", "balancedValue") := NULL]
toPrintCane[, c("adjustment", "balancedValue") := NULL]
printDistributionTable(toPrintBeet, params)
})})
suppressMessages({suppressWarnings({
printDistributionTable(toPrintCane, params)
})})
```

We can now adjust our SUA table with the updated/balanced values:

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
# save(sugarData, tree, file = paste0(workingDir, "standardizedSugar1.RData"))
# load(paste0(workingDir, "standardizedSugar1.RData"))
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := FALSE]
toPrint[measuredItemCPC == caneSugarCode & element %in% c("5510", "f???"),
        updateFlag := TRUE]
toPrint[measuredItemCPC == beetSugarCode & element == "f???",
        updateFlag := TRUE]
printTable(toPrint, params, workingDir)
})})
```

We must now process the changes in the current elements down the tree into the other elements.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
## Allocate down the adjustments in the true/automated way
sink("temp.txt") # Sink balancing output so it doesn't get printed.
sugarData = rollDownFoodDelta(data = sugarData, tree = tree,
                              standParams = params,
                              feedElements = c("23140.01", "39120.01"))
sink()
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, adjustment := NULL]
toPrint[, updateFlag := (measuredItemCPC == refinedSugarCode) &
            (element %in% c(params$productionCode, params$stockCode,
                            params$foodCode))]
printTable(toPrint, params, workingDir)
})})
```

Lastly, some elements have not yet been updated in this process.  To ensure a full balance of the SUA, we should go through and balance those rows as well.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
finalSuaBalance(sugarData, standParams = params,
                feedElements = c())
toPrint = sugarData[timePointYears == "2011", ]
toPrint[, updateFlag := element == params$foodCode &
            measuredItemCPC %in% c(sugarSyrupCode)]
printTable(toPrint, params, workingDir)
})})
```

Now, we standardize all these commodities into their primary equivalents: in this case, cane sugar and beet sugar.  Commodities with multiple parents must be processed back into all the parents according to shares determined in the processing step (for example, refined sugar back to cane and beet in the proportion given earlier).

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
params$elementPrefix = ""
invisible({
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[, share := 1]
## Don't standardize back bagasse, beet pulp, or molasses
standTree = standTree[!parentID %in% c("01801", "01802"), ]
standTree[childID %in% c(bagasseCode, beetPulpCode, molassesCode),
          extractionRate := Inf]
})
standTree[parentID == beetSugarCode & childID == refinedSugarCode,
          share := c(as.numeric(gsub("%", "",
                        splitRatio$Percent[splitRatio$Name == "Beet sugar"]))/100)]
standTree[parentID == caneSugarCode & childID == refinedSugarCode,
          share := c(as.numeric(gsub("%", "",
                        splitRatio$Percent[splitRatio$Name == "Cane sugar, centrifugal"]))/100)]
params$elementPrefix = ""
finalValues = finalStandardizationToPrimary(data = sugarData, tree = standTree,
                                            standParams = params,
                                            sugarHack = FALSE)
finalValues = finalValues[timePointYears == "2011" &
    get(params$itemVar) %in% c(caneSugarCode, beetSugarCode), ]
printTable(finalValues, standParams = params, workingDir)
})})
```

We can also compute calories, fats, and proteins at this point.  First, we apply a calorie/fat/protein content factor to each individual element:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

load(paste0(workingDir, "nutrientData.RData"))
# Loads object "nutrientData"
    
toPrint = sugarData[timePointYears == "2011" & element == params$foodCode, ]
toPrint = merge(toPrint, nutrientData, by = params$itemVar, all.x = TRUE)

## Don't print some elements
skippedElements = c(24110, 2413, 23210.05, 24490.92)
toPrint = toPrint[!get(params$itemVar) %in% skippedElements, ]

setnames(itemName, params$childVar, params$itemVar)
toPrint = merge(toPrint[, c(params$itemVar, "Value", "Protein", "Fat", "Energy"),
                        with = FALSE], itemName, all.x = TRUE)
setnames(itemName, params$itemVar, "Item")
toPrint[, measuredItemCPC := NULL]

setcolorder(toPrint, c("Name", "Value", "Energy", "Protein", "Fat"))
setnames(toPrint, "Value", "Quantity")
knitr::kable(toPrint)

})})
```

Standardization of calories is simpler since we don't need to divide by extraction rates: the standardized calories/fats/proteins are the sum of the total calories/fats/proteins for each element.  However, this is more complicated than simply adding up calories/fats/proteins because we have to standardize children commodities into multiple parents.  For example, as with the quantity standardization, we should standardize refined sugar back into cane sugar and beet sugar according to the proportion from processing:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
out = toPrint[, list(
    Energy  = sum(Quantity * Energy , na.rm = TRUE)/1000000,
    Protein = sum(Quantity * Protein, na.rm = TRUE)/1000000,
    Fat     = sum(Quantity * Fat    , na.rm = TRUE)/1000000), by = ""]
out = round(out, 2)
out = rbind(out, out)
out[, Energy := Energy * c(0.616, 0.408)]
out[, Protein := Protein * c(0.616, 0.408)]
out[, Fat := Fat * c(0.616, 0.408)]
out[, Standardized_Equivalent := c("Beet Sugar", "Cane Sugar")]
setcolorder(out, c("Standardized_Equivalent", "Energy", "Protein", "Fat"))
setnames(out, colnames(out)[-1], paste(colnames(out)[-1], "(millions)"))
knitr::kable(out)
})})
```