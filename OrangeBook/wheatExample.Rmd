---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
---

# Food Balance Sheets Compilation at the national level

The two principal data pillars for the compilation of the Food Balance Sheets (FBS), whether at the national level or at FAO, are the agricultural trade and production data. The trade data are, on the whole, quite accurately recorded and compiled by the national Customs Office, based on the appropriate filled-in forms and on manual checks. The production data are obtained from the national surveys, which are most often yield-based extrapolations. Production and trade (imports and exports) are the main variables of the "supply" side of the FBS.

Reliable data for the other variables of the FBS balancing equation, such as withdrawals or additions from/to stocks (supply), feed, seed, industiral use, loss, etc, (all part of utilization) may or may not be available at the national level, depending on the agricultural data collection framework in a given country. In the absence of such data, one must resort to impuation using the methodolgies described in detail in the preceding chapter.

The FBS equation, as we saw earlier:

Supply: 

**Production + Imports - Exports - Stock changes = **

Utilization:

**Food + Feed + Seed + Tourist consumption + Industrial use + Loss + Residuals/other utilizations**

Note that the "Food" variable listed here is the sum of the food for the commodity eaten as such as well as the food for any processed commodities.  For wheat, this amounts to the (standardized) sum of the processed products, but for a commodity like pineapples this would be the sum of pineapples eaten as such as well as the quantity of pineapples consumed as juices, canned pineapples, etc.

Of major importance in the FBS calculation is the "Food" component, expressed in Kcal/person/day.  It is essential to bear in mind that this "Food" is an indicator of "availability", as a national average, and not of actual "consumption".  Household consumption data are more accurately obtained from the various household surveys. The differences between the "food" data from the FBS and the "consumption" from the household surveys are described in detail elsewhere in this manual (such as the absence of data reflecting the public consumption of food in restaurants, at street level, etc. in the household surveys).

The possible data sources for the other variables (such as the agri-food industry data) have been listed elsewhere in this manual.

In this chapter, we will show a step-by-step example of the FBS compilation, starting with the detailed Supply Utilization Accounts (SUA) of a given country in a given year, for a few selected commodities. These SUAs are then aggregated to produce the FBS. The "Residuals/other utilizations" variable will be omitted in the example, in order to simplify the steps.

```{r, echo = FALSE, eval = FALSE}
# # Wrap in an R comment to prevent printing:
# # TO DO
# ## Important Tasks
# - Review trade portion from Alex and incorporate into this document.
# - Discuss trade for countries with access to customs and without.
# - Balancing algorithm: determine a good way to choose the tolerance automatically.  It's manually tuned in this example, and that clearly won't work for general food balance sheet processes.
# - Add text/content to the document to provide more explanation of each example.
# 
# ## Minor Tasks
# - Loss module: clean up the functions in the one script and put them into individual files with roxygen-style documentation (even if very sparse at the moment).  This is crucial for transferring this work back to an R module on the system.
# - All modules: clean up hard-coded numbers, column names, etc.
# - The trade figures I quote here are based on the US data, but not exactly.  We have HS6 trade data, and I can map that to CPC.  However, some HS6 codes map to many CPC codes.  My understanding is that the historical approach has been to not use split factors and to simply map the quantity straight into one of the CPC codes.  For this simple example, I map the HS data to CPC and randomly split it.
# - The commodity trees used are derived based on the FCL commodity tree.  They will likely need to be updated, but for now I just simply map the FCL elements to their corresponding CPC codes.  At the least, it would be good to have a tree for processing and a tree for standardization (some elements, for example beer, bran, etc. do not standardize up to the same thing they were processed from).
```

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees

## Wheat codes
wheatCode = "0111"
flourCode = "23110"
bulgurCode = "23140.02"
cerealsCode = "23140.03"
starchCode = "23220.01"
branCode = "39120.01"
germCode = "23140.01"

## Sugar codes
beetCode = "01801"
caneCode = "01802"
beetSugarCode = "23512"
caneSugarCode = "23511.01"
refinedSugarCode = "23520"
molassesCode = "23540"
bagasseCode = "39140.02"
beetPulpCode = "39140.01"

currentCountry = "840"
currentYear = "2011"

# Never use scientific notation.
options(scipen = 100)
# options(digits = 0)

if(Sys.info()[7] == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] == "Golini"){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}

## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancing.R"))
source(paste0(workingDir, "../../Balancing_ML/R/forceBalance.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancingNormal.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(params$productionCode, params$feedCode, params$seedCode,
                params$wasteCode, params$foodCode, params$stockCode,
                params$importCode, params$exportCode)
wheatKeys = c("0111", "23110", "23140.01", "23140.02", "23140.03", "23220.01",
              "23220.02", "23490.02", "23710", "39120.01", "F0020", "F0022")
cattleKeys = c("02111", "21111.01", "21111.02", "21182", "21184.01", "21185",
               "21512.01", "23991.04", "F0875")
palmOilKeys = c("01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120")
sugarKeys = c("01802", "23512", "F7156", "23210.04", "2351", "23511", "23520",
              "23540", "23670.01", "24110", "2413", "24131", "24139",
              "24490.92", "39140.02", "F7157", "01801", "39140.01", "F7161",
              "01809", "F7162", "F7163")
milkKeys = c("02211", "22110.01", "22110.02", "22110.03", "22211", "22212",
             "22221.01", "22221.02", "22222.01", "22222.02", "22230.01",
             "22230.02", "22230.03", "22230.04", "22241.01", "22241.02",
             "22251.01", "22251.02", "22251.03", "2251.04", "22260",
             "23210.06")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
fullData = fullData[timePointYears == currentYear &
                        geographicAreaM49 == currentCountry, ]
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
## Set up empty variable for food processing
foodProcVar = paste0(params$elementPrefix, params$foodProcCode)
fullData[, c(foodProcVar) := NA_real_]
## Set up empty variable for industrial utilization
indVar = paste0(params$elementPrefix, params$industrialCode)
fullData[, c(indVar) := NA_real_]
## Set up empty variable for tourist consumption
touVar = paste0(params$elementPrefix, params$touristCode)
fullData[, c(touVar) := NA_real_]

pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120", "f???")

tree = fread(paste0(workingDir, "standardizationTree.csv"),
             colClasses = c("character", "character", "numeric", "character",
                            "numeric", "character", "numeric"))
## Don't want infinite extraction rates until standardization, so just make up
## some
## Butcher fat to cattle meat
tree[parentID == "21111.01" & childID == "21512.01", extractionRate := 0.05]
## Cake of palm kernels to palm kernels
tree[parentID == "01491.02" & childID == "21910.06", extractionRate := 0.10]
## Gluten to flour
tree[parentID == "23110" & childID == "23220.02", extractionRate := 0.5]
## Conversion to CPC was slightly problematic: Beet sugar gets processed into 
## element "23510" for which we have no data (and the CPC code doesn't seem to 
## exist in the online UN directory: 
## http://unstats.un.org/unsd/cr/registry/docs/CPCv2_structure.pdf.  So, Beet
## sugar and Cane sugar will be processed directly to Refined sugar (for the
## purpose of this example at least).
tree = tree[!parentID == "23510" & !childID == "23510", ]
tree = rbindlist(list(tree,
                      data.table(childID = "23520", target = "B",
                                 extractionRate = 0.92,
                                 parentID = c(23511.01, 23512),
                                 calorieExtractionRate = 1,
                                 groupID = c("23511.01-23520", "23512-23520"))),
                 fill = TRUE)
edges = tree[(parentID %in% sugarKeys | childID %in% sugarKeys) &
                 !is.na(parentID) & !is.na(childID), ]

itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))

## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Wheat

For this example, we will first consider the full process for creating a food balance sheet for wheat.  Note that if we do not otherwise mention the units, all quantities are assumed to be in millions of tonnes.  We start off with an empty SUA table showing some commodities of the wheat "commodity tree" (wheat as the primary commodity, flour, etc. as the processed commodities):

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
wheatData = fullData[measuredItemCPC %in% wheatKeys, ]
wheatData = data.table:::melt.data.table(data = wheatData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
wheatData[grepl("Value", variable), variableType := "Value"]
wheatData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
wheatData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = wheatData, formula = as.formula(castFormula),
#                             value.var = "value")
wheatData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(wheatData, "variable", "element")
wheatData = tidyr::spread(data = wheatData, key = "variableType", value = "value")
wheatData[, Value := as.numeric(Value)]
## Remove alot of the data, and "impute" it later
wheatData[element %in% fbsElements, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures. To impute any missing production figures, we must also consider "yield" and "area harvested" (in the absense of "area sown") data, since yield is defined as production divided by area harvested (and thus with any two variables the third is uniquely defined).

Suppose we only have the official data below. Please note that for the sake of demonstration we have considered the flour quantities as given, and the wheat as unknown and must therefore be imputed. In reality, of course, it is almost always the reverse (with wheat production officially available, and flour less so):

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear &
                        measuredItemCPC %in% c("0111", "23110"), ]
## Force wheat to be missing except for area harvested
toPrint[measuredItemCPC == "0111" & element %in% c("5510", "5421"), Value := NA]
toPrint[measuredItemCPC == "0111" & element == "5312", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5312]]
## Force flour to be missing except for production
toPrint[measuredItemCPC == "23110" & element %in% c("5312", "5421"), Value := NA]
toPrint[measuredItemCPC == "23110" & element == "5510", Value := 
    fullData[measuredItemCPC == "23110" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

In this case, the production quantity is only known for wheat flour (it is missing for wheat), and for wheat we are also missing the yield value.  We follow the following process in determining how to impute production data:
- If all three variables (area harvested, yield, and production) are missing, we impute yield and production data using the historical time series (using the ensemble approach).
- If one variable is available, and this variable is not the yield, then we impute yield using the historical time series (using the ensemble approach).
- If the yield variable is available, we impute production using the historical time series (using the ensemble approach).
- If two variables are available, the third is computed to satisfy the identity.
- If all three variables are available, we check the identity.  If it does not hold, we recommend examining all three figures to detect if one is incorrect.

The first step in the imputation process is to impute the yield, using the previously described production imputation methodology.  This approach imputes the yield value using a time series analysis.  In the graph below, several models are fit to the historical yield values (models are represented as lines and historical data as points).  These models are combined in a weighted average (where the weights are chosen based on how well the model fits the data) to form a final ensemble of models.  This ensemble is used to predict the yield value in the current year.  In this case, we are examining 2011 and the ensemble estimate is 2.94 tonnes/hectare.

```{r, echo = FALSE, fig.height=6, fig.width = 8}
suppressWarnings({suppressMessages({
library(faoswsImputation)
set.seed(123)
sink("temp.txt")
data = fullData[measuredItemCPC == "0111" & geographicAreaM49 == currentCountry,]
data[, timePointYears := NULL]
data = merge(data, data.table(timePointYears = 1991:2011, geographicAreaM49 = "840"),
             by = "geographicAreaM49")
data[, Value_measuredElement_5421 := c(NA, NA, rnorm(18, mean = 1, sd = .1), NA) *
         (1-1/(.5*1:21)) + rbinom(21, size = 1, prob = .2)]
data[, Value_measuredElement_5421 := Value_measuredElement_5421 * 2.9422/0.888242]
data[, flagObservationStatus_measuredElement_5421 := 
         ifelse(is.na(Value_measuredElement_5421), "M", "")]
data[, geographicAreaM49 := ""]
impParams = defaultImputationParameters(variable = 5421)
names(impParams$ensembleModels) = gsub("default", "", names(impParams$ensembleModels))
setnames(data, "Value_measuredElement_5421", "Yield")
impParams$imputationValueColumn = "Yield"
impParams$ensembleModels = impParams$ensembleModels[1:9]
sink()
imputeVariable(data, imputationParameters = impParams)
})})
```

The final imputed value for yield in 2011 is 2.94 tonnes/hectare, which is a reasonable estimate when compared to the historical time series.  Some models fit the data fairly well (such as the logistic regression, spline, and ARIMA).  Some of these models do not produce good forecasts (in particular, the forecast for the loess model is quite low) but by averaging together well-performing models, we get a good final estimate for the yield.  See chapter 2 for further details on these models and the ensemble imputation approach.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5421", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5421]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

Now, we have enough information to compute the production data:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5510", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

```{r, echo = FALSE}
suppressWarnings({suppressMessages({invisible({
wheatData = merge(wheatData,
                  fullData[measuredItemCPC %in% wheatKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
wheatData[element == "5510", Value := Value_measuredElement_5510]
wheatData[, standardDeviation := 0]
wheatData[element == "5510" & measuredItemCPC == "0111",
          standardDeviation := Value * .01]
wheatData[element == "5510" & Value == 0, Value := NA]
wheatData[, Value_measuredElement_5510 := NULL]
})})})
```

Next, we fill in the table with our imputed and official production quantities.  Production is only imputed for primary products (and occassionally official figures are provided for processed products, as is the case here).  So, in this case, no additional quantities are filled in outside of wheat and flour.

```{r, echo = FALSE, fig.show = FALSE}
suppressWarnings({suppressMessages({

# procParams = defaultProcessingParameters(productionValue = 5510,
#                                          yieldValue = 5421,
#                                          areaHarvestedValue = 5312)
# yieldParams = defaultImputationParameters(variable = 5421)
# prodIParams = defaultImputationParameters(variable = 5510)
# # procParams$byKey <- yieldParams$byKey <- prodIParams$byKey <-
# #     c("geographicAreaM49", "measuredItemCPC")
# yieldParams$estimateNoData <- prodIParams$estimateNoData <- TRUE
# imputeProductionDomain(data = wheatData[measuredItemCPC == "0111", ],
#                        processingParameters = procParams,
#                        yieldImputationParameters = yieldParams,
#                        productionImputationParameters = prodIParams)
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

The next step is to include the trade data. Trade data are usually recorded in much more detail, covering more commodities, than production data. The total imports and exports (the aggregated trade flows) for each respective commodity, as reported by the customs office, are inserted in the table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
wheatData = replaceData(wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
wheatData = replaceData(wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
wheatData[element == "5600" & measuredItemCPC == "23140.02" &
              timePointYears == "2011", Value := 182485]
wheatData[element == "5900" & measuredItemCPC == "23140.03" &
              timePointYears == "2011", Value := 217289]
wheatData[element == "5600" & Value == 0, Value := NA]
wheatData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
wheatData = wheatData[geographicAreaM49 == currentCountry, ]
# params$mergeKey = params$mergeKey[2:3]

toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

SALAR TO INSERT EXAMPLE OF TRADE MIRRORING AND U.V.-BASED QUANTITY CORRECTION.

For all the next steps, this example will consider all the data for the various variables as unavaiable, and thus all the figures are to be imputed.

### Stock Changes

We now estimate the stock changes.  Generally, stocks will be held for a select number of primary level products (such as wheat or rice).  The numbers below represent the estimated stock changes for the example country we are considering.  The stock imputation methodology, as described more thoroughly in chapter 2, estimates stock change in the current year as a linear regression on the cumulative stock changes in the previous years.  In this case, our estimate represents a withdrawal (hence the negative sign) in the stocks held.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
wheatData = replaceData(wheatData,
    stockEstimates[, c("Value_measuredElement_71",
                       "standardDeviation_measuredElement_71",
                       params$mergeKey),
                   with = FALSE],
    mergeKey = params$mergeKey)
wheatData[is.na(Value) & element == "71", Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The module estimating food allocation uses food consumption estimates from the previous year and extrapolates these estimates forward using changes in GDP and product elasticities.  The allocation to food can potentially be considered for any item at the SUA level; however, the food module estimates consumption at the primary level only by standardizing/aggregating all the consumption quantities to the primary level.  This food quantity will eventually be processed into child commodities to cover trade imbalances or provide consumption at lower levels.  We now impute food consumption numbers (as per the methodology) for the example country and update the SUA table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[is.na(share), share := 1]
foodEstimates = standardizeTree(data = foodEstimates, tree = standTree,
                                elements = "5141", standParams = params)
foodEstimates[, standardDeviation_measuredElement_5141 := .1 * Value_measuredElement_5141]
wheatData = replaceData(wheatData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# wheatData[element == "5141" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141"]
printTable(toPrint, params, workingDir)
})})
```


### Feed

The Feed variable is then imputed (see the methodology described in detail in Chapter 2, based on the animal numbers and feed "intensification" factors, resulting in calculated feed requirements). The assumption here is that some of the primary level quantities are used as feed, as well as all of the bran (which is a by-product of the flour production process).  Negligible amounts of bran do go into such products as breakfast cereals, but for the sake of simplicity, such quantities will be ignored in this example.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/feedEstimates.RData"))
## Hack the feed estimate for bran to make the example work better
feedEstimates[measuredItemCPC == branCode, Value_measuredElement_5520 := 3355525]
feedEstimates[, standardDeviation_measuredElement_5520 :=
                  Value_measuredElement_5520 * .05]
wheatData = replaceData(wheatData,
            feedEstimates[, c("Value_measuredElement_5520",
                               "standardDeviation_measuredElement_5520",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5520" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```

### Losses

These refer to post-harvest losses prior to the retail stage. Retail and household losses/wastes are therefore not included here. The methodology for calculating agricultural and food losses is continuously being revised and improved.  Currently, the methodology, as described in chapter 2, uses information about the perishable group of a commodity and the country/region to estimate a hierarchical linear regression model.  Also, it should be noted here that losses are assumed to occur only at the primary level.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
wheatData = replaceData(wheatData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[is.na(Value) & element == "5120", Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

The seed quantities are then imputed (again based on the methodology described in chapter 2). The seed module fits a hierarchical linear model to seed data in previous years and uses global data.  Seed, of course, is only allotted to the primary commodity.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, Value_measuredElement_5525 := seedPredicted]
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  exp(seedVariance)]
wheatData = replaceData(wheatData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[is.na(Value) & element == "5525", Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

For most commodities, there is no industrial utilization and therefore its quantity will be zero.  The estimates from this commodity are often taken from external sources; see the methodology discussion in chapter 2.  This element can be important when considering commodities related to biofuels (such as maize) and vegetable oils (such as palm oil).  For the wheat "commodity tree," the main commodity that has industrial use is "wheat starch."

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
wheatData = replaceData(wheatData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
wheatData[is.na(Value) & element == "i???", Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the World Trade Organization (UNWTO) to compute tourist flows as well as previous year consumption patterns of the country of origin to estimate tourist consumption amounts while abroad.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, the country will have a negative ``tourist consumption'' because more calories will be consumed abroad than locally.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates = touristEstimates[geographicAreaM49 == "840", ]
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[is.na(share), share := 1]
touristEstimates = standardizeTree(data = touristEstimates, tree = standTree,
                                   elements = "tou", standParams = params)
touristEstimates[, standardDeviation_measuredElement_tou := 
                     1 * Value_measuredElement_tou]
setnames(touristEstimates, "Value_measuredElement_tou",
         "Value_measuredElement_t???")
setnames(touristEstimates, "standardDeviation_measuredElement_tou",
         "standardDeviation_measuredElement_t???")
wheatData = replaceData(wheatData,
            touristEstimates[, c("Value_measuredElement_t???",
                                 "standardDeviation_measuredElement_t???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
wheatData[is.na(Value) & element == "t???", Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "t???"]
printTable(toPrint, params, workingDir)
})})
```

### Standardization and Balancing

Now, suppose we have the following wheat commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
edges = tree[parentID %in% wheatKeys, ]
setnames(itemName, "Item", params$parentVar)
edges = merge(edges, itemName, by = params$parentVar, all.x = TRUE)
edges[, c("parentID", "Name") := list(Name, NULL)]
setnames(itemName, params$parentVar, params$childVar)
edges = merge(edges, itemName, by = params$childVar, all.x = TRUE)
edges[, c("childID", "Name") := list(Name, NULL)]
edges[, childID := gsub(" ", "\n", childID)]
edges[, parentID := gsub(" ", "\n", parentID)]
setnames(itemName, params$childVar, "Item")
plotSingleTree(edges = edges, parentColname = "parentID",
               childColname = "childID", extractionColname = "extractionRate",
               box.size = .08, box.type = "circle", cex.txt = 2, box.prop = .5,
               box.cex = 1.9)
})})
```

We first start with the pre-standardized table that we have so far compiled:

```{r, echo = FALSE}
# save(wheatData, file = paste0(workingDir, "preStandardizedWheat.RData"))
# load(paste0(workingDir, "preStandardizedWheat.RData"))
suppressWarnings({suppressMessages({
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

We could balance the wheat line of the SUA at this point, but we may run into a problem.  Suppose, for example, that the food quantity is adjusted downwards during the balancing.  In the case of wheat, there is no consumption as such.  Thus, this quantity of food will then be converted into production for the processed products according to the commodity tree (i.e. production of flour, bulgur, and breakfast cereals).  If the food quantity is too small, we may not be able to generate the official flour production, or we may not produce enough bulgur to cover the trade deficit.  Therefore, we first must compute the required ``production'' of each of the processed products to ensure that we'll satisfy any deficits due to exports or consumption (note that required production can be zero if supply exceeds utilization and we have no official production data).

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
## Production = Exports + Food - Imports
## 5510 = 5900 + 71 - 5600
computeProcessedProduction(data = wheatData, tree = tree, standParams = params)
wheatData[element == "5510" & Value < 0, Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := (element == "5510" & Value < 18000000)]
printTable(toPrint, params, workingDir)
})})
```

Since wheat starch is a derived by-product of wheat flour production (as is wheat bran), we would first need to ensure the wheat flour "production" can cover any deficits of wheat starch. However, since wheat starch imports, in this example, exceed exports, we do not have to worry here about this requirement. Therefore, we can now standardize all the processed product quantities back to the food element of wheat. The standardized quantities will, of course, be in the primary commodity (in this case wheat) equivalents. For example, suppose that 100 tonnes of a primary commodity produces 50 tonnes of the processed product (a 50% extraction rate). Therefore, these 50 tonnes of the processed product will be standardised back as 100 tonnes of wheat equivalent.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
distributionTable = toPrint[measuredItemCPC %in% c(flourCode, bulgurCode,
                                                   cerealsCode, branCode) &
                                element == params$productionCode,
                            list(measuredItemCPC, Value, standardDeviation)]
setnames(distributionTable, c("Item", "prodMean", "prodSd"))
distributionTable[, wheatMean := prodMean / c(.72, .95, 1, .22)]
distributionTable[, wheatSd := prodSd / c(.72, .95, 1, .22)]
printStandardizationTable(distributionTable, params, workingDir = workingDir)
})})
```

The main requirement is in the wheat flour and bran, and it should be noted that the 24.7 million tonnes requirement for wheat bran will automatically be satisfied if the 25.9 million tonnes requirement for wheat bran is satisfied (as they are produced together).  Thus, the lower bound for the food variable for wheat must be 26.3 million tonnes (the total requirement from flour and bulgur).  Moreover, flour production is an official figure, and this means that we should not allow the food production quantity of wheat to change much (as any changes would imply an increase in flour production, which is not correct, or an increase in production of bulgur/breakfast cereals).  Thus, we fix the food variable of wheat to 26.3 million tonnes by setting the standard deviation of flour to 0.

Now, we must balance to satisfy the FBS equation of supply equals utilization.  To do this, we need to extract the computed standard deviations of each variable.  The table below shows the expected value and estimated standard deviation for each of the variables for wheat.  The equation is not initially balanced, and it is balanced by adjusting figures according to their standard deviations.  For example, a variable with a large standard deviation can be adjusted substantially (as we are not very confident in this figure) while a variable with zero standard deviation will not be adjusted at all (see more on this algorithm in chapter 2).

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
invisible(toPrint[, updateFlag := NULL])
toPrint = toPrint[measuredItemCPC == "0111", ]
toPrint[is.na(standardDeviation), standardDeviation := 0]
## Fix food of wheat since flour is official
wheatData[measuredItemCPC == "0111" & element == "5141", Value := 26330000]
wheatData[measuredItemCPC == "0111" & element == "5141", standardDeviation := 0]
toPrint[measuredItemCPC == "0111" & element == "5141", Value := 26330000]
toPrint[measuredItemCPC == "0111" & element == "5141", standardDeviation := 0]
printDistributionTable(toPrint, params)
})})
```

Note that in this case, the standard deviation for food is quite large, but it cannot be adjusted down much because of the lower bound we computed above.  Thus, the food variable is not adjusted much in the balancing process.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
toPrint = toPrint[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode), ]
sink("temp.txt") # Sink balancing output so it doesn't get printed.
toPrint[, balancedValue := balancing(param1 = sapply(Value, na2zero),
              param2 = sapply(standardDeviation, na2zero),
              sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
              lbounds = ifelse(element %in% c(params$stockCode, params$touristCode), -Inf,
                        ifelse(element == params$foodCode, 26328000, 0)),
              optimize = "constrOptim", constrTol = 1e-6)]
sink()
toPrint[, adjustment := balancedValue - Value]
wheatData = merge(wheatData,
                  toPrint[, !c("Value", "metFlag", "obsFlag", "standardDeviation"),
                          with = FALSE],
                  by = c(params$mergeKey, "element"), all.x = TRUE)
wheatData[!is.na(balancedValue), Value := balancedValue]
wheatData[, balancedValue := NULL]
toPrint[, Value := balancedValue]
toPrint[, c("adjustment", "balancedValue") := NULL]
printDistributionTable(toPrint, params)
})})
```

We can now update the production quantities for each of the derived/processed commodities.  As already mentioned, in the process of creating flour, we also create bran and germ. The amount of bran and germ created, in this case, is determined by the amount of flour we need to create (as that was our most stringent requirement). Thus, we have:

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
## Add in default shares for all processing activities
invisible({
tree[, share := NA_real_]
tree[groupID == "0111-23110", share := .90]
tree[groupID == "0111-23140.02", share := .05]
tree[groupID == "0111-23140.03", share := .05]
})
## Allocate down the adjustments in the true/automated way
# save(wheatData, file = paste0(workingDir, "StandardizedWheat1.RData"))
# load(paste0(workingDir, "StandardizedWheat1.RData"))
sink("temp.txt") # Sink balancing output so it doesn't get printed.
wheatData = synchronizeByProducts(data = wheatData, tree = tree,
                                  standParams = params)
wheatData = rbind(wheatData, data.table(measuredItemCPC = germCode,
                                        element = c("5600", "5900", "71", "5525",
                                                    "5120", "t???", "i???", "5520"),
                                        geographicAreaM49 = "840",
                                        timePointYears = "2011",
                                        metFlag = NA,
                                        obsFlag = NA,
                                        Value = 0,
                                        standardDeviation = NA,
                                        adjustment = NA))
wheatData[measuredItemCPC == germCode & element == "5520", Value := NA]
sink()
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## rollDownFoodDelta is currently more complicated than it should be.  Undo some
## changes that it does that shouldn't be done (it should only create production
## for by-products).
toPrint[get(params$itemVar) == branCode & element == params$feedCode,
        Value := 3355500]
toPrint[, adjustment := NULL]
toPrint[, updateFlag := (measuredItemCPC == germCode) |
            (element %in% c(params$productionCode) &
                 measuredItemCPC %in% c(germCode, branCode))]
printTable(toPrint, params, workingDir)
})})
```
 
Now our food balance sheet is nearly completed, except that we have not balanced the SUA commodities yet.  Since the production is already fixed (either because it is an official figure or because it is 0) the balancing is very straightforward: the difference (which must be positive because we enforced this above) will be entirely allocated to the most sensible element (often food, but occassionally feed or industrial use).

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
finalSuaBalance(wheatData, standParams = params,
                feedElements = c(branCode, germCode),
                indElements = starchCode)
toPrint = wheatData[timePointYears == "2011", ]
toPrint[, updateFlag := element %in% c(params$foodCode, params$feedCode,
                                       params$industrialCode) &
            measuredItemCPC != wheatCode & Value > 0]
printTable(toPrint, params, workingDir)
})})
```

Now, the final step is to aggregate this full table back into the primary commodity equivalent (in this case wheat).  The final quantity for wheat equivalent production is simply the current quantity for wheat production.  This is because "production" of bulgur (or any other processed product) is really a conversion of wheat into bulgur and not actually a production of bulgur.  Thus, the reported quantity for production will always just be the production at the primary product level.  For a similar reason, the food variable is not standardized: the food quantity reported for wheat corresponds to the quantity of wheat eaten as such (which for this commodity is zero) as well as the food processed into other products.

To standardize imports and exports, we can aggregate the imports and exports of the derived/processed commodities up into their primary equivalent by dividing by the extraction rate.  We add these primary equivalents to the current quantity of imports and exports of wheat, and we have our final, primary equivalent import and export quantities of wheat.

Feed commodity quantities (such as bran quantities) are not standardized back into their primary (wheat) equivalent as they are feed products.  Thus, they are not reported at all in the food balance sheet but are instead reported in the commodity balances under a category such as "brans."  For the remaining variables, standardization is simple in that we just use the primary value: for example, the final stock change for wheat will simply be the current stock change as there is no stock change for processed products.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
params$elementPrefix = ""
invisible({
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[, share := 1]
## Don't standardize back germ and bran
standTree[parentID == "0111" & childID == "39120.01", extractionRate := Inf]
standTree[parentID == "0111" & childID == "23140.01", extractionRate := Inf]
})
params$elementPrefix = ""
finalValues = finalStandardizationToPrimary(data = wheatData, tree = standTree,
                                            standParams = params)
finalValues = finalValues[timePointYears == "2011", ]
printTable(finalValues, standParams = params, workingDir)
})})
```

We can now calculate the calories, fats, and proteins content. First, we apply the calorie/fat/protein content nutritive factors to each individual commodity with a non-zero food value.  These nutritive factors are obtained from national sources or from international standard tables.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

load(paste0(workingDir, "nutrientData.RData"))
# Loads object "nutrientData"
    
toPrint = wheatData[timePointYears == "2011" & element == params$foodCode, ]
toPrint = merge(toPrint, nutrientData, by = params$itemVar, all.x = TRUE)
toPrint[measuredItemCPC == wheatCode & element == "5141", Value := 0]

setnames(itemName, "Item", params$itemVar)
toPrint = merge(toPrint[, c(params$itemVar, "Value", "Protein", "Fat", "Energy"),
                        with = FALSE], itemName, all.x = TRUE)
setnames(itemName, params$itemVar, "Item")
toPrint = toPrint[!is.na(Value), ]
toPrint[, measuredItemCPC := NULL]

setcolorder(toPrint, c("Name", "Value", "Energy", "Protein", "Fat"))
setnames(toPrint, "Value", "Quantity")
toPrintCopy = copy(toPrint)
toPrint[, Quantity := sapply(Quantity, roundNum)]
toPrint[, Energy := round(Energy, 0)]
toPrint[, Protein := round(Protein, 2)]
toPrint[, Fat := round(Fat, 2)]
knitr::kable(toPrint, align = c("l", "r", "r", "r", "r"))

})})
```

Standardization of nutrients is now a simple last step: all the variables here (i.e. calories, fats, and proteins) are purely additive, so the standardized calories/fats/proteins are simply the sum of the total calories/fats/proteins for each commodity:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
out = toPrintCopy[, list(
    Energy  = sum(Quantity * Energy , na.rm = TRUE)/1000000,
    Protein = sum(Quantity * Protein, na.rm = TRUE)/1000000,
    Fat     = sum(Quantity * Fat    , na.rm = TRUE)/1000000), by = ""]
out[, Energy := round(Energy/100, 0)*100]
out[, Protein := round(Protein, 0)]
out[, Fat := round(Fat, 0)]
setnames(out, colnames(out), paste(colnames(out), "(millions)"))
out = cbind(data.table(Commodity = "Wheat and Products"), out)
knitr::kable(out, align = c("l", "r", "r", "r"))
})})
```