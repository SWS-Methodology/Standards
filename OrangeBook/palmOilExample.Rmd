---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
---

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees

currentCountry = "840"
currentYear = "2011"

palmFruitCode = "01491.01"
palmOilCode = "2165"
palmKernelOilCode = "21691.14"
palmKernelCode = "01491.02"
palmKernelCakeCode = "21910.06"
fattyAcidCode = "F2199"
hydroOilCode = "F1275"
fatPrepCode = "F1243"
margarineCode = "21700.02"
liqMargarineCode = "21700.01"

# Never use scientific notation.
options(scipen = 100)
# options(digits = 0)

if(Sys.info()[7] == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] == "Golini"){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}

## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancing.R"))
source(paste0(workingDir, "../../Balancing_ML/R/forceBalance.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancingNormal.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(params$productionCode, params$feedCode, params$seedCode,
                params$wasteCode, params$foodCode, params$stockCode,
                params$importCode, params$exportCode, params$foodProcCode)
palmOilKeys = c("01491.01", "01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120", "F2199")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
fullData = fullData[get(params$itemVar) %in% palmOilKeys, ]
fullData = fullData[timePointYears == currentYear &
                        geographicAreaM49 == currentCountry, ]
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
## Set up empty variable for food processing
foodProcVar = paste0(params$elementPrefix, params$foodProcCode)
fullData[, c(foodProcVar) := NA_real_]
## Set up empty variable for industrial utilization
indVar = paste0(params$elementPrefix, params$industrialCode)
fullData[, c(indVar) := NA_real_]
## Set up empty variable for tourist consumption
touVar = paste0(params$elementPrefix, params$touristCode)
fullData[, c(touVar) := NA_real_]

pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120", "f???")

tree = fread(paste0(workingDir, "standardizationTree.csv"),
             colClasses = c("character", "character", "numeric", "character",
                            "numeric", "character", "numeric"))
## Don't want infinite extraction rates until standardization, so just make up
## some
## Butcher fat to cattle meat
tree[parentID == "21111.01" & childID == "21512.01", extractionRate := 0.05]
## Cake of palm kernels to palm kernels
tree[parentID == "01491.02" & childID == "21910.06", extractionRate := 0.10]
## Gluten to flour
tree[parentID == "23110" & childID == "23220.02", extractionRate := 0.5]
## Conversion to CPC was slightly problematic: Beet sugar gets processed into 
## element "23510" for which we have no data (and the CPC code doesn't seem to 
## exist in the online UN directory: 
## http://unstats.un.org/unsd/cr/registry/docs/CPCv2_structure.pdf.  So, Beet
## sugar and Cane sugar will be processed directly to Refined sugar (for the
## purpose of this example at least).
tree = tree[!parentID == "23510" & !childID == "23510", ]
tree = rbindlist(list(tree,
                      data.table(childID = "23520", target = "B",
                                 extractionRate = 0.92,
                                 parentID = c(23511.01, 23512),
                                 calorieExtractionRate = 1,
                                 groupID = c("23511.01-23520", "23512-23520"))),
                 fill = TRUE)
edges = tree[(parentID %in% palmOilKeys | childID %in% palmOilKeys) &
                 !is.na(parentID) & !is.na(childID), ]

itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))

## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Palm Oil

For this example, we'll first consider the full process for creating a food balance sheet for wheat.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
palmOilData = fullData[measuredItemCPC %in% palmOilKeys, ]
palmOilData = data.table:::melt.data.table(data = palmOilData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
palmOilData[grepl("Value", variable), variableType := "Value"]
palmOilData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
palmOilData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = palmOilData, formula = as.formula(castFormula),
#                             value.var = "value")
palmOilData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(palmOilData, "variable", "element")
palmOilData = tidyr::spread(data = palmOilData, key = "variableType", value = "value")
palmOilData[, Value := as.numeric(Value)]
## Remove alot of the data, and "impute" it later
palmOilData[element %in% fbsElements, Value := NA]
toPrint = palmOilData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  In this case, the production quantity is known for all the primary products and thus no imputation is done.  If we were to have missing quantities, we would impute data as described in chapter two and as shown in the wheat example.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
palmOilData = merge(palmOilData,
                  fullData[measuredItemCPC %in% palmOilKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
palmOilData[element == "5510", Value := Value_measuredElement_5510]
palmOilData[, standardDeviation := 0]
palmOilData[element == "5510" & Value == 0, Value := NA]
palmOilData[element == "5510" & measuredItemCPC == palmFruitCode, Value := 0]
palmOilData[, Value_measuredElement_5510 := NULL]
toPrint = palmOilData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

Please reference chapter 2 and the wheat example for a thorough description of the trade processing.  For this example, we simply insert the available trade figures.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% palmOilKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
palmOilData = replaceData(originalData = palmOilData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% palmOilKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
palmOilData = replaceData(originalData = palmOilData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
# palmOilData[element == "5600" & measuredItemCPC == "23140.02" &
#               timePointYears == "2011", Value := 182485]
# palmOilData[element == "5900" & measuredItemCPC == "23140.03" &
#               timePointYears == "2011", Value := 217289]
palmOilData[element == "5600" & Value == 0, Value := NA]
palmOilData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
palmOilData = palmOilData[geographicAreaM49 == currentCountry, ]

palmOilData[is.na(Value) & element %in% c("5600", "5900"), Value := 0]

toPrint = palmOilData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

### Stock Changes

Generally, stocks will be held for a select number of primary level products (such as wheat or rice).  However, in the case of sugar, it is not uncommon for countries to hold stocks for processed commodities such as raw or refined sugar.  The stock change in the table will ideally be a quantity measured within the country, but in almost all cases this is not possible.  Thus, the stock change quantity must be imputed, and we do this imputation via the linear regression model on historical stock change data described more thoroughly in chapter 2.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
palmOilData = replaceData(palmOilData,
            stockEstimates[, c("Value_measuredElement_71",
                               "standardDeviation_measuredElement_71",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
palmOilData[is.na(Value) & element == "71", Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The module estimating food allocation uses food consumption estimates from the previous year and extrapolates these estimates forward using changes in GDP and product-related income elasticities.  Recall that the "Food" variable is only reported at the primary level as the "Food Processing" variable is estimated by standardizing the "Food" quantities for all the processed commodities.  Also, sugar is a special case in that the food balance is not done at the level of the sugar crops (i.e. sugar cane and sugar beet) but rather at the level of raw sugar.  Thus, when we later refer to the "primary level" for sugar, we will really mean the raw sugar commodity.  Now, the "Food" and "Food Processing" variables are filled in for raw sugar.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
palmOilData = rbind(palmOilData, data.table(measuredItemCPC = palmFruitCode,
                                            element = c("5600", "5900", "71", "5525", "5141",
                                                        "5120", "t???", "i???", "f???", "5520"),
                                            geographicAreaM49 = "840",
                                            timePointYears = "2011",
                                            metFlag = NA,
                                            obsFlag = NA,
                                            Value = NA,
                                            standardDeviation = NA))
palmOilData[measuredItemCPC %in% c(palmFruitCode) &
                element %in% c("5600", "5900", "71"),
          Value := 0]
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[is.na(share), share := 1]
foodEstimates = standardizeTree(data = foodEstimates,
                                tree = standTree,
                                elements = "5141", standParams = params,
                                sugarHack = FALSE)
foodEstimates[, standardDeviation_measuredElement_5141 := .1 * Value_measuredElement_5141]
setnames(foodEstimates, colnames(foodEstimates), gsub("_5141", "_f???", colnames(foodEstimates)))
palmOilData = replaceData(palmOilData,
            foodEstimates[, c("Value_measuredElement_f???",
                               "standardDeviation_measuredElement_f???",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
## Assign a food value for raw sugar to make the example more interesting (and
## different from wheat).
palmOilData[element == "5141" & measuredItemCPC == palmFruitCode, Value := 0]
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# palmOilData[element == "5141" & Value == 0, Value := NA]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := (element %in% c("5141", "f???") &
                          measuredItemCPC == palmFruitCode)]
printTable(toPrint, params, workingDir)
})})
```

### Losses

Losses are estimated using the methodology described in chapter 2, unless losses quantities are measured by the country.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
palmOilData = replaceData(palmOilData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
palmOilData[is.na(Value) & element == "5120", Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

As the country of interest has no production of palm oil fruit, no amount will be allocated to seed.  Thus, we can fill the table in with zeros.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  Value_measuredElement_5525 * .1]
palmOilData = replaceData(palmOilData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
palmOilData[element == "5525" & is.na(Value), Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

As with the wheat example, few of the sugar commodities are used for industrial use.  However, bagasse, a byproduct in the processing of sugar cane into raw sugar, can be utilized in industry.  This allocation will be made later when we convert the sugar cane quantities into its processed products.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
palmOilData = replaceData(palmOilData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
palmOilData[element == "i???" & Value == 0, Value := NA]
palmOilData[element == "i???" & measuredItemCPC == palmFruitCode, Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

As with the wheat example, we see a negative tourist consumption amount.  This indicates that more calories are available in the country (a decrease in utilization is mathematically equivalent to an increase in supply) because inhabitants consumed calories abroad.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates = standardizeTree(data = touristEstimates,
                                   tree = standTree,
                                   elements = "tou", standParams = params,
                                   sugarHack = FALSE)
touristEstimates[, standardDeviation_measuredElement_tou := 
                     1 * Value_measuredElement_tou]
setnames(touristEstimates, old = "Value_measuredElement_tou",
         new = "Value_measuredElement_t???")
setnames(touristEstimates, old = "standardDeviation_measuredElement_tou",
         new = "standardDeviation_measuredElement_t???")
palmOilData = replaceData(palmOilData,
            touristEstimates[, c("Value_measuredElement_t???",
                               "standardDeviation_measuredElement_t???",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
palmOilData[element == "t???" & is.na(Value), Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "t???"]
printTable(toPrint, params, workingDir)
})})
```

### Feed

For the palm oil commodity tree, only one element is allocated to feed (cakes of palm kernels).  This commodity is a byproduct in the processing of palm kernels into oil of palm kernels.  However, for the country we are considering, no palm kernels are available.  Thus, neither "oil of palm kernels" nor "cake of palm kernels" are produced.  Also, palm oil itself is never fed directly to animals, and thus we have no commodity to allocate any feed to.  Thus, all feed is assumed to be 0.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
palmOilData[element == "5520" & is.na(Value), Value := 0]
toPrint = palmOilData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```
