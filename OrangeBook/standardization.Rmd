---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
header-includes:
   - \usepackage[table,xcdraw]{xcolor}
---


```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees
wheatCode = "0111"
flourCode = "23110"
bulgurCode = "23140.02"
cerealsCode = "23140.03"
starchCode = "23220.01"
branCode = "39120.01"
germCode = "39120.02"

currentCountry = "840"
currentYear = "2011"

#aaaa

# Never use scientific notation, don't print decimals either.
options(scipen = 100, digits = 0)

if(Sys.getenv("USER") == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.getenv("USER") %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}
## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(5113, 5025, 5312, 5510, 5327, 5421, 5520, 5525,
                5120, 5023, 5141, 71, 5600, 5900)
wheatKeys = c("0111", "23110", "23140.01", "23140.02", "23140.03", "23220.01",
              "23220.02", "23490.02", "23710", "39120.01", "F0020", "F0022")
cattleKeys = c("21111.01", "21111.02", "21182", "21184.01", "21185",
               "21512.01", "23991.04", "F0875")
palmOilKeys = c("01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120")
## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Wheat

For this example, we'll first consider the commodity tree for wheat.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
wheatData = fullData[measuredItemCPC %in% wheatKeys, ]
wheatData = data.table:::melt.data.table(data = wheatData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
wheatData[grepl("Value", variable), variableType := "Value"]
wheatData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
wheatData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = wheatData, formula = as.formula(castFormula),
#                             value.var = "value")
wheatData[, variable := gsub("[A-Za-z_]*", "", variable)]
setnames(wheatData, "variable", "element")
wheatData = tidyr::spread(data = wheatData, key = "variableType", value = "value")
## Remove alot of the data, and "impute" it later
wheatData[, Value := rep(0, nrow(wheatData))]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  To impute production, we must also consider yield and area harvested data as yield is defined as production divided by area harvested (and thus with any two elements the third is uniquely defined).  Suppose we have the following official data:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear &
                        measuredItemCPC %in% c("0111", "23110"), ]
## Force wheat to be missing except for area harvested
toPrint[measuredItemCPC == "0111" & element %in% c("5510", "5421"), Value := 0]
toPrint[measuredItemCPC == "0111" & element == "5312", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5312]]
## Force flour to be missing except for production
toPrint[measuredItemCPC == "23110" & element %in% c("5312", "5421"), Value := NA]
toPrint[measuredItemCPC == "23110" & element == "5510", Value := 
    fullData[measuredItemCPC == "23110" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
## Remove alot of the data, and "impute" it later
printProductionTable(toPrint)

})})
```

In this case, the production value is only known for wheat flour (it is missing for wheat), and for wheat we are also missing the yield value.  The first step in the imputation process is to impute the yield, using the previously described production imputation methodology.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5421", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5421]]
## Remove alot of the data, and "impute" it later
printProductionTable(toPrint)

})})
```

Now, we have enough information to impute the production data:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5510", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
## Remove alot of the data, and "impute" it later
printProductionTable(toPrint)

})})
```

```{r, echo = FALSE}
suppressWarnings({suppressMessages({invisible({
wheatData = merge(wheatData,
                  fullData[measuredItemCPC %in% wheatKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
wheatData[element == "5510", Value := Value_measuredElement_5510]
wheatData[element == "5510" & Value == 0, Value := NA]
wheatData[, Value_measuredElement_5510 := NULL]
wheatData[, standardDeviation := 0]
})})})
```

Now, we fill in the table with our production values.  Production is only imputed for primary products, and so in this case no additional values are filled in.

```{r, echo = FALSE, fig.show = FALSE}
suppressWarnings({suppressMessages({

# procParams = defaultProcessingParameters(productionValue = 5510,
#                                          yieldValue = 5421,
#                                          areaHarvestedValue = 5312)
# yieldParams = defaultImputationParameters(variable = 5421)
# prodIParams = defaultImputationParameters(variable = 5510)
# # procParams$byKey <- yieldParams$byKey <- prodIParams$byKey <-
# #     c("geographicAreaM49", "measuredItemCPC")
# yieldParams$estimateNoData <- prodIParams$estimateNoData <- TRUE
# imputeProductionDomain(data = wheatData[measuredItemCPC == "0111", ],
#                        processingParameters = procParams,
#                        yieldImputationParameters = yieldParams,
#                        productionImputationParameters = prodIParams)
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)

})})
```

### Trade

For the next example, we'll show how the imputation, mirroring and balancing works.  In this case, we just take the country totals and insert into this table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
replaceData(originalData = wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
replaceData(originalData = wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
wheatData[element == "5600" & Value == 0, Value := NA]
wheatData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
wheatData = wheatData[geographicAreaM49 == currentCountry, ]
params$mergeKey = params$mergeKey[2:3]

toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Print the trade data
printTable(toPrint)
})})
```

NOTE (Josh): The trade figures I quote here are based on the US data, but not exactly.  We have HS6 trade data, and I can map that to CPC.  However, some HS6 codes map to many CPC codes.  My understanding is that the historical approach has been to not use split factors and to simply map the quantity straight into one of the CPC codes.  For this simple example, I map the HS data to CPC and randomly split it.

### Stock Changes

We now estimate the stock changes.  Note that for most products, we assume that countries do not hold stocks.  Generally, stocks will only be held for primary level products, and not even all of these products.  The numbers below represent the estimated stock changes (by the stock imputation methodology described previously) for the example country we're considering.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
replaceData(wheatData,
            stockEstimates[, c("Value_measuredElement_71",
                               "standardDeviation_measuredElement_71",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "71" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Food

The allocation to food, on the other hand, can potentially be considered at any processing level, although some commodities (such as wheat) are assumed to not be eaten as such.  We impute food consumption numbers for the example country and update the FBS table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
replaceData(wheatData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# wheatData[element == "5141" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .2]
replaceData(wheatData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5120" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
warning("Standard error for loss data is currently just 20% of loss value, it ",
        "is not estimated in any way.")
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  Value_measuredElement_5525 * .2]
replaceData(wheatData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5525" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
warning("Standard error for seed data is currently just 20% of seed value, it ",
        "is not estimated in any way.")
```

### Industrial Utilization

Work in progress...

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the WTO as well as last year's consumption patterns to estimate the impact of tourism on local consumption.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, that country will certainly have a negative ``tourist consumption'' because more calories will be assumed abroad than locally.

### Residual Other Uses

Work in progress...

### Standardization

Now, suppose we have the following commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
tree = fread(paste0(workingDir, "standardizationTree.csv"))
plotSingleTree(edges = tree[parentID %in% wheatKeys, ],
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .08,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

NOTE (Josh): This commodity tree above is derived based on the FCL commodity tree.  It will likely need to be updated, but for now I just simply map the FCL elements to their corresponding CPC codes.

NOTE (Josh): At this point, we should also compute calories/proteins/fats.

NOTE (Josh): Need to keep track of the standard deviations as well so that we can balance at the end.

```{r, echo = FALSE}
wheatDataSaved = copy(wheatData)
```

```{r, echo = FALSE, eval = FALSE}
## Wrapping in an R loop as a "comment"
#### Standardization Approach 1

We first standardize all commodities up or down the commodity tree to the first processing level equivalent.  We do this element-by-element, and thus we represent trade and food consumption of derived products in their first-processing level equivalent (which seems very natural/reasonable).  However, we also do this for the primary product: we translate production of wheat into production of flour/bran/germ; stock changes of wheat into stock changes of flour/bran/germ; etc.  For all elements except production, this standardization is additive (i.e. the imports of flour are added to the standardized imports of wheat, bread, etc. to get the total standardized imports of flour).  For production, this should not occur as you never truly have ``production'' of processed products.  However, if production of a processed product is reported, that means that the standardized primary product must provide for this production and thus we update the shares to give us the correct amount here.  Thus, our table is updated as follows:

suppressWarnings({suppressMessages({
wheatData = wheatData[, c("measuredItemCPC", "timePointYears", "geographicAreaM49",
                          paste0("Value_measuredElement_", fbsElements)), with = FALSE]
## NOTE: This standardization process below should eventually go into the
## standardizeNew function in faoswsAupus.
tree1 = copy(tree)
areaVar = "geographicAreaM49"
yearVar = "timePointYears"
byKey = c(areaVar, yearVar)
shares = fread(paste0(workingDir, "shareData.csv"),
               colClasses = c("character", "character", "numeric", "numeric"))
## Cartesian product to expand default shares/extraction rates to country/year specifc
mergeKeys = wheatData[, .N, byKey]
## Use N as a key to merge on
mergeKeys[, N := 1]
tree1[, N := 1]
tree1 = merge(tree1, mergeKeys, by = "N", allow.cartesian = TRUE)
tree1[, N := NULL]
setnames(shares, c("measuredItemParentFS", "measuredItemChildFS"),
         c("parentID", "childID"))
tree1 = merge(tree1, shares, by = c("parentID", "childID"), all.x = TRUE)

## If we already have production for a processed product (i.e. flour), we need
## to update the shares so that the processing of wheat into flour is reasonable
## and doesn't lead to vastly wrong extraction rates.  We must also update the
## shares for all other products by scaling them up or down proportionally.
toMerge = wheatData[, list(measuredItemCPC, geographicAreaM49, timePointYears,
                   Value_measuredElement_5510)]
## Get keys for when we have production of a processed product:
implicitShare = toMerge[!is.na(Value_measuredElement_5510) &
                        measuredItemCPC %in% unique(tree1$childID), ]
setnames(implicitShare, c("measuredItemCPC", "Value_measuredElement_5510"),
         c("childID", "productionChild"))
tree1 = merge(tree1, implicitShare, by = c(byKey, "childID"),
              all = TRUE)
## Get the production of the parent product as well
setnames(toMerge, c("measuredItemCPC", "Value_measuredElement_5510"),
         c("parentID", "productionParent"))
tree1 = merge(tree1, toMerge, by = c(byKey, "parentID"),
               all.x = TRUE)
## Add in the extraction rate
tree1[, newShare := 100 * productionChild / extractionRate / productionParent]
## Update the share value based on the implicit calculation.  If multiple 
## implicit shares are defined in one processing group (i.e. production of flour
## AND bran is available), then we'll average the implicit shares.  This seems
## very unlikely to ever occur, though...
tree1[, newShare := mean(newShare, na.rm = TRUE),
       by = c(byKey, "parentID", "groupID")]
tree1[, Value_share := ifelse(is.na(newShare), Value_share, newShare)]
## Scale up shares that haven't been defined
tree1[, firstInGroup := !duplicated(groupID), by = c(byKey, "parentID")]
tree1[, implicitSum := sum(newShare * firstInGroup, na.rm = TRUE),
       by = c(byKey, "parentID")]
## Scale non-implicit shares.  They should sum up to 100-implicitSum, and they 
## currently sum up to sum(Value_share * firstInGroup) over the group (using
## firstInGroup to de-duplicate the extraction processes with multiple outputs. 
## So, we just use that ratio to scale up/down.
tree1[is.na(newShare),
       Value_share := Value_share * (100 - implicitSum) /
           sum(Value_share * firstInGroup), by = c(byKey, "parentID")]
warning("This approach may be problematic if implicitSum goes over 100.",
        "We could get negative shares!")

## If Value_share is not NA, this is a primary to first processing edge.  To
## compute extraction rate, the parent * share * oldExtraction = quantity of the
## child.  Thus, to compute an "extraction rate" from the child to the parent,
## we'll take 1/(share * extractionRate).
reversedTree = copy(tree1)
reversedTree[, reverseEdge := !is.na(Value_share)]
reversedTree[(reverseEdge), c("parentID", "childID", "extractionRate", "Value_share") :=
          list(childID, parentID, 100 / extractionRate / Value_share, 100)]
## If the extraction rate from the true parent to the child was Inf (i.e. no
## processing) then we would have an extraction rate from the child back to the
## parent of 0.  This will give us infinities in our standardization, and really
## we just want to force no processing along this edge.  Thus, set
## extractionRate here to Inf.
reversedTree[reverseEdge & extractionRate == 0, extractionRate := Inf]

## Convert shares to 0 to 1 rather than 0 to 100
reversedTree[, Value_share := Value_share / 100]

## Before standardizing, remove production amounts of processed commodities. 
## These will come in automatically from production of the parent commodity.
wheatData[!is.na(Value_measuredElement_5510) &
          measuredItemCPC %in% shares$childID,
          Value_measuredElement_5510 := NA]

## Technically, we shouldn't be standardizing production up, but production of
## lower commodities should all be 0 anyways.
step1 = standardizeTree(data = wheatData, tree = reversedTree, elements = fbsElements,
                yearVar = "timePointYears", geoVar = "geographicAreaM49",
                itemVar = "measuredItemCPC", elementPrefix = "Value_measuredElement_",
                shareVar = "Value_share")
toPrint = step1[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})

To illustrate the calculations occuring in this step, we first focus on one specific element: the imports for 23140.02.  This commodity originally had `r wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear & measuredItemCPC == "23140.02", Value_measuredElement_5600]` kg reported.  However, all children commodities must be rolled up into this first level processing element (in this case there are none) and all primary products must be processed down according to the default shares and extraction rates.  In this case, the share of 0111 to 23140.02 was `r tree1[childID == "23140.02" & timePointYears == currentYear, ]`\% and the extraction rate was `r round(tree[childID == "23140.02", extractionRate]*100, 0)`\%.  Thus, we will take the imports for 0111, i.e. `r wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear & measuredItemCPC == "0111", Value_measuredElement_5600]`, and multiply it by the share while dividing by the extraction rate.  This gives a increase of `r wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear & measuredItemCPC == "0111", Value_measuredElement_5600]*shares[childID == "23140.02", Value_share]/(100*tree[childID == "23140.02", extractionRate])` kg to the import of element 23140.02, thus the final import value is `r wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear & measuredItemCPC == "0111", Value_measuredElement_5600]*shares[childID == "23140.02", Value_share]/(100*tree[childID == "23140.02", extractionRate]) + wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear & measuredItemCPC == "23140.02", Value_measuredElement_5600]`.

**Problem: Flour, in this case, receives a very low share because the production of wheat is so high and so much is exported.  Thus, we shouldn't be standardizing production in this way but rather the food from wheat should flow into the production of flour and other derived products.**

#### Standardization Approach 2

We first start with the pre-standardized table:

suppressWarnings({suppressMessages({
wheatData = copy(wheatDataSaved)
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})

We then standardize the food values up to Wheat to get an estimate for food for the primary commodity:

suppressWarnings({suppressMessages({
toPrint[measuredItemCPC == "0111", Value_measuredElement_5141 := 
            18539484/.72 + 3684/.95 + 98131/1]
printTable(toPrint)
})})

Now, we balance the primary product:

suppressWarnings({suppressMessages({
toPrint[measuredItemCPC == "0111", Value_measuredElement_5510 := Value_measuredElement_5510]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5600 := Value_measuredElement_5600]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5900 := Value_measuredElement_5900]
diff = toPrint[measuredItemCPC == "0111",
               Value_measuredElement_5510 + Value_measuredElement_5600 -
                   Value_measuredElement_5900 - Value_measuredElement_71 -
                   Value_measuredElement_5525 - Value_measuredElement_5120 -
                   Value_measuredElement_5141]
stockDelta = diff * .4
foodDelta = diff * .2
wasteDelta = diff * .2
seedDelta = diff * .2
toPrint[measuredItemCPC == "0111", Value_measuredElement_71 := Value_measuredElement_71 + stockDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5525 := Value_measuredElement_5525 + seedDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5120 := Value_measuredElement_5120 + wasteDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5141 := Value_measuredElement_5141 + foodDelta]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
printTable(toPrint)
})})

This updated value for food can now be allocated to the production of children commodities (via multiplication of the shares and extraction rates).

**Problem: At this point, the amount allocated to wheat food is not enough to cover offical flour production.  We could attempt to bound the distribution of food at the minimum amount to create the flour production, but in this case the optimum would be on that boundary and so we'd have no wheat to allocate to the other commodities.  This will then cause other problems if those commodities have higher exports/food than imports.**

**Question: How do we pass the food element into production in the subelements?**
```

We first start with the pre-standardized table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
wheatData = copy(wheatDataSaved)
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})
```

We then compute the required ``production'' of each of the processed products to satisfy any deficits due to exports or consumption (note that we can allow production to be zero if supply exceeds utilization).

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
## Production = Exports + Food - Imports
## 5510 = 5900 + 71 - 5600
computeProcessedProduction(data = wheatData, tree = tree, standParams = params)
wheatData[element == "5510" & Value < 0, Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})
```

Since wheat starch is produced from wheat flour, we would first need to ensure the wheat flour food can cover any deficits of wheat starch.  However, since wheat starch imports exceed exports plus food, we don't have to worry about this requirement.  Instead, we can just standardize all the first processed level products back to food of wheat.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
distributionTable = toPrint[measuredItemCPC %in% c(flourCode, bulgurCode,
                                                   cerealsCode, branCode) &
                                element == "5510",
                            list(measuredItemCPC, Value, standardDeviation)]
setnames(distributionTable, c("Item", "prodMean", "prodSd"))
distributionTable[, prodSd := prodMean * .25]
distributionTable[Item == flourCode, prodSd := 0]
distributionTable[, wheatMean := prodMean / c(.72, .95, 1, .22)]
distributionTable[, wheatSd := prodSd / c(.72, .95, 1, .22)]
printStandardizationTable(distributionTable)
})})
```

Now, we wish to compute the distribution for food for wheat.  The main requirement is in the wheat flour, and it should be noted that the 9 million kilogram requirement for wheat bran will automatically be satisfied if the 26 million kilogram requirement for wheat flour is satisfied (as they are by-products).  Thus, the food element for wheat has a mean of 26,198 thousand kilograms (the sum of the first three) and a standard deviation of 63 thousand kilograms (the square-root of the sum of the squares of the first three standard deviations).  Thus, we now have the following table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
## Production = Exports + Food - Imports
## 5510 = 5900 + 71 - 5600
toPrint[measuredItemCPC == wheatCode, Value_measuredElement_5141 := 26198393]
printTable(toPrint)
})})
```

Now, we balance this table, and find that the food value is adjusted down slightly:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
toPrint[measuredItemCPC == "0111", Value_measuredElement_5510 := Value_measuredElement_5510]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5600 := Value_measuredElement_5600]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5900 := Value_measuredElement_5900]
diff = toPrint[measuredItemCPC == "0111",
               Value_measuredElement_5510 + Value_measuredElement_5600 -
                   Value_measuredElement_5900 - Value_measuredElement_71 -
                   Value_measuredElement_5525 - Value_measuredElement_5120 -
                   Value_measuredElement_5141]
stockDelta = diff * .54
foodDelta = diff * .01
wasteDelta = diff * .1
seedDelta = diff * .35
toPrint[measuredItemCPC == "0111", Value_measuredElement_71 := Value_measuredElement_71 + stockDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5525 := Value_measuredElement_5525 + seedDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5120 := Value_measuredElement_5120 + wasteDelta]
toPrint[measuredItemCPC == "0111", Value_measuredElement_5141 := Value_measuredElement_5141 + foodDelta]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
# toPrint[measuredItemCPC == "0111", Value_measuredElement_5 := ]
printTable(toPrint)
})})
```

Now, food gets adjusted in the balance, and this adjustment proportionally flows down to all the children according to their variability.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
distributionTable[1:3, adjustment := foodDelta * wheatSd / sum(wheatSd)]
distributionTable[is.na(adjustment), adjustment := 0]
distributionTable[, wheatMean := wheatMean - adjustment]
distributionTable[, prodMean := prodMean - adjustment / c(.72, .95, 1, .22)]
distributionTable[, adjustment := NULL]
printStandardizationTable(distributionTable)
})})
```

We can now update the production numbers for each of the first level primary elements.  Note that in the process of creating flour, we also create bran and germ.  The amount of bran and germ created, in this case, is determined by the amount of flour we need to create (as that was our most stringent requirement).  Thus, we have:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
toPrint[measuredItemCPC == bulgurCode, Value_measuredElement_5510 := 44617]
toPrint[measuredItemCPC == cerealsCode, Value_measuredElement_5510 := 245363]
toPrint[measuredItemCPC == branCode, Value_measuredElement_5510 := 18652048*.22/.72]
toPrint = rbindlist(list(toPrint,
    data.table(measuredItemCPC = germCode, Value_measuredElement_5510 = 18652048*.22/.72)),
    fill = TRUE)
printTable(toPrint)
})})
```

Additionally, we must enforce consistent shares/extraction rates across grouped commodities (for example, flour/bran/germ) and so when flowing back down we will create excess production of some of the by-products.

**Problem: How do we allocate the excess when processing back down?  Should this excess be directly allocated to food/feed (depending on the commodity)?  Or maybe we do a balance at the SUA level and allocate a little to trade as well, if trade is not official?**

### Feed

Feed allocation must be done at this phase in order to ensure that we have reduced the feed demand by the corresponding amounts of feed products (i.e. wheat bran, wheat germ, etc.).

### Balancing


```{r, echo = FALSE}
## We're done with wheat, so let's remove that data to make sure we don't
## reference it later on accident.
rm(wheatData)
```

## Cattle Meat

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
cattleData = fullData[measuredItemCPC %in% cattleKeys, ]
## Remove alot of the data, and "impute" it later
cattleData[, Value_measuredElement_5520 := 0]
cattleData[, Value_measuredElement_5525 := 0]
cattleData[, Value_measuredElement_5120 := 0]
cattleData[, Value_measuredElement_5141 := 0]
cattleData[, Value_measuredElement_71 := 0]
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})
```

### Production

```{r, echo = FALSE, fig.show = FALSE, eval = FALSE}
suppressWarnings({suppressMessages({

procParams = defaultProcessingParameters(productionValue = 5510,
                                         yieldValue = 5421,
                                         areaHarvestedValue = 5312)
yieldParams = defaultImputationParameters(variable = 5421)
prodIParams = defaultImputationParameters(variable = 5510)
# procParams$byKey <- yieldParams$byKey <- prodIParams$byKey <-
#     c("geographicAreaM49", "measuredItemCPC")
yieldParams$estimateNoData <- prodIParams$estimateNoData <- TRUE
imputeProductionDomain(data = cattleData[measuredItemCPC == "0111", ],
                       processingParameters = procParams,
                       yieldImputationParameters = yieldParams,
                       productionImputationParameters = prodIParams)
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)

## No longer need other countries, so drop them!
cattleData = cattleData[geographicAreaM49 == currentCountry, ]

})})
```

### Trade

### Stock Changes

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
cattleData = merge(cattleData, stockEstimates[, c("Value", "measuredItemCPC"),
                                             with = FALSE],
                  by = "measuredItemCPC", all.x = TRUE)
cattleData[, Value_measuredElement_71 := Value]
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
cattleData[, Value := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Food

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
cattleData = merge(cattleData, foodEstimates[, c("mean", "measuredItemCPC", "geographicAreaM49"),
                                           with = FALSE],
                  by = c("measuredItemCPC", "geographicAreaM49"), all.x = TRUE)
cattleData[, Value_measuredElement_5141 := mean]
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
cattleData[, mean := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
cattleData = merge(lossEstimates[, c("Value_measuredElement_5120",
                                    "measuredItemCPC"), with = FALSE],
                  cattleData, by = "measuredItemCPC", all.y = TRUE,
                  suffixes = c(".loss", ""))
cattleData[, Value_measuredElement_5120 := Value_measuredElement_5120.loss]
cattleData[, Value_measuredElement_5120.loss := NULL]
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
cattleData = merge(seedEstimates[, c("Value_measuredElement_5525",
                                    "measuredItemCPC"), with = FALSE],
                  cattleData, by = "measuredItemCPC", all.y = TRUE,
                  suffixes = c(".seed", ""))
cattleData[, Value_measuredElement_5525 := Value_measuredElement_5525.seed]
toPrint = cattleData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
cattleData[, Value_measuredElement_5525.seed := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Industrial Utilization

Work in progress...

### Tourist Consumption

Work in progress...

### Residual Other Uses

Work in progress...

### Standardization

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
tree = fread(paste0(workingDir, "standardizationTree.csv"))
plotSingleTree(edges = tree[parentID %in% cattleKeys & !is.na(childID), ],
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .08,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

```{r, echo = FALSE}
# suppressWarnings({suppressMessages({
# cattleData = cattleData[, c("measuredItemCPC", "timePointYears", "geographicAreaM49",
#                           paste0("Value_measuredElement_", fbsElements)), with = FALSE]
# tree1 = copy(tree)
# shares = fread(paste0(workingDir, "shareData.csv"))
# setnames(shares, c("measuredItemParentFS", "measuredItemChildFS"),
#          c("parentID", "childID"))
# tree1 = merge(tree1, shares, all = TRUE, by = c("childID", "parentID"))
# ## If Value_share is not NA, this is a primary to first processing edge
# tree1[!is.na(Value_share), c("parentID", "childID", "extractionRate") :=
#           list(childID, parentID, 100*extractionRate/Value_share)]
# tree1[, Value_share := NULL]
# tree1[, share := 1]
# tree1[, geographicAreaM49 := currentCountry]
# tree1[, timePointYears := currentYear]
# step1 = standardizeTree(data = cattleData, tree = tree1, elements = fbsElements,
#                 yearVar = "timePointYears", geoVar = "geographicAreaM49",
#                 itemVar = "measuredItemCPC", elementPrefix = "Value_measuredElement_")
# toPrint = step1[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
# ## Remove alot of the data, and "impute" it later
# printTable(toPrint)
# })})
```

### Feed

### Balancing

```{r, echo = FALSE}
rm(cattleData)
```


## Palm Oil

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
palmData = fullData[measuredItemCPC %in% palmOilKeys, ]
## Remove alot of the data, and "impute" it later
palmData[, Value_measuredElement_5520 := 0]
palmData[, Value_measuredElement_5525 := 0]
palmData[, Value_measuredElement_5120 := 0]
palmData[, Value_measuredElement_5141 := 0]
palmData[, Value_measuredElement_71 := 0]
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint)
})})
```

### Production

```{r, echo = FALSE, fig.show = FALSE, eval = FALSE}
suppressWarnings({suppressMessages({

procParams = defaultProcessingParameters(productionValue = 5510,
                                         yieldValue = 5421,
                                         areaHarvestedValue = 5312)
yieldParams = defaultImputationParameters(variable = 5421)
prodIParams = defaultImputationParameters(variable = 5510)
# procParams$byKey <- yieldParams$byKey <- prodIParams$byKey <-
#     c("geographicAreaM49", "measuredItemCPC")
yieldParams$estimateNoData <- prodIParams$estimateNoData <- TRUE
imputeProductionDomain(data = palmData[measuredItemCPC == "0111", ],
                       processingParameters = procParams,
                       yieldImputationParameters = yieldParams,
                       productionImputationParameters = prodIParams)
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)

## No longer need other countries, so drop them!
palmData = palmData[geographicAreaM49 == currentCountry, ]

})})
```

### Trade

### Stock Changes

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
palmData = merge(palmData, stockEstimates[, c("Value", "measuredItemCPC"),
                                           with = FALSE],
                  by = "measuredItemCPC", all.x = TRUE)
palmData[, Value_measuredElement_71 := Value]
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
palmData[, Value := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Food

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
palmData = merge(palmData, foodEstimates[, c("mean", "measuredItemCPC", "geographicAreaM49"),
                                           with = FALSE],
                  by = c("measuredItemCPC", "geographicAreaM49"), all.x = TRUE)
palmData[, Value_measuredElement_5141 := mean]
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
palmData[, mean := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
palmData = merge(lossEstimates[, c("Value_measuredElement_5120",
                                    "measuredItemCPC"), with = FALSE],
                  palmData, by = "measuredItemCPC", all.y = TRUE,
                  suffixes = c(".loss", ""))
palmData[, Value_measuredElement_5120 := Value_measuredElement_5120.loss]
palmData[, Value_measuredElement_5120.loss := NULL]
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
palmData = merge(seedEstimates[, c("Value_measuredElement_5525",
                                    "measuredItemCPC"), with = FALSE],
                  palmData, by = "measuredItemCPC", all.y = TRUE,
                  suffixes = c(".seed", ""))
palmData[, Value_measuredElement_5525 := Value_measuredElement_5525.seed]
toPrint = palmData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
palmData[, Value_measuredElement_5525.seed := NULL]
## Remove alot of the data, and "impute" it later
printTable(toPrint)
})})
```

### Industrial Utilization

Work in progress...

### Tourist Consumption

Work in progress...

### Residual Other Uses

Work in progress...

### Standardization

NOTE (Josh): This commodity tree looks like two separate trees.  But, the two parent nodes can actually be processed into many of the same children.  I'm not sure what the logic was for historically rolling up some of the children into one of the parents and some of the children into the other parent, but that would presumably need to be reviewed/revised.

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
tree = fread(paste0(workingDir, "standardizationTree.csv"))
plotSingleTree(edges = tree[parentID %in% palmOilKeys, ],
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .08,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

```{r, echo = FALSE}
# suppressWarnings({suppressMessages({
# palmData = palmData[, c("measuredItemCPC", "timePointYears", "geographicAreaM49",
#                           paste0("Value_measuredElement_", fbsElements)), with = FALSE]
# tree1 = copy(tree)
# shares = fread(paste0(workingDir, "shareData.csv"))
# setnames(shares, c("measuredItemParentFS", "measuredItemChildFS"),
#          c("parentID", "childID"))
# tree1 = merge(tree1, shares, all = TRUE, by = c("childID", "parentID"))
# ## If Value_share is not NA, this is a primary to first processing edge
# tree1[!is.na(Value_share), c("parentID", "childID", "extractionRate") :=
#           list(childID, parentID, 100*extractionRate/Value_share)]
# tree1[, Value_share := NULL]
# tree1[, share := 1]
# tree1[, geographicAreaM49 := currentCountry]
# tree1[, timePointYears := currentYear]
# step1 = standardizeTree(data = palmData, tree = tree1, elements = fbsElements,
#                 yearVar = "timePointYears", geoVar = "geographicAreaM49",
#                 itemVar = "measuredItemCPC", elementPrefix = "Value_measuredElement_")
# toPrint = step1[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
# ## Remove alot of the data, and "impute" it later
# printTable(toPrint)
# })})
```

### Feed

### Balancing

```{r, echo = FALSE}
rm(palmData)
```