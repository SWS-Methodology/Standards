---
title: "Food Balance Sheets"
output: pdf_document
classoption: landscape
---

```{r, echo = FALSE, eval = FALSE}
# # Wrap in an R comment to prevent printing:
# # TO DO
# ## Important Tasks
# - Review trade portion from Alex and incorporate into this document.
# - Discuss trade for countries with access to customs and without.
# - Balancing algorithm: determine a good way to choose the tolerance automatically.  It's manually tuned in this example, and that clearly won't work for general food balance sheet processes.
# - Add text/content to the document to provide more explanation of each example.
# - Round printed values.  If there are only 1 or 2 digits, the final value should be the closest multiple of 5.  If 3 digits, a multiple of 10, 4 to 7 digits a multiple of 100, and 8+ digits then 4 significant digits.
# 
# ## Minor Tasks
# - Loss module: clean up the functions in the one script and put them into individual files with roxygen-style documentation (even if very sparse at the moment).  This is crucial for transferring this work back to an R module on the system.
# - All modules: clean up hard-coded numbers, column names, etc.
# - The trade figures I quote here are based on the US data, but not exactly.  We have HS6 trade data, and I can map that to CPC.  However, some HS6 codes map to many CPC codes.  My understanding is that the historical approach has been to not use split factors and to simply map the quantity straight into one of the CPC codes.  For this simple example, I map the HS data to CPC and randomly split it.
# - The commodity trees used are derived based on the FCL commodity tree.  They will likely need to be updated, but for now I just simply map the FCL elements to their corresponding CPC codes.  At the least, it would be good to have a tree for processing and a tree for standardization (some elements, for example beer, bran, etc. do not standardize up to the same thing they were processed from).
```

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
library(data.table)
# library(faoswsProduction)
# library(faoswsImputation)
# library(faoswsSeed)
library(diagram) # For plotting commodity trees

## Wheat codes
wheatCode = "0111"
flourCode = "23110"
bulgurCode = "23140.02"
cerealsCode = "23140.03"
starchCode = "23220.01"
branCode = "39120.01"
germCode = "23140.01"

## Sugar codes
beetCode = "01801"
caneCode = "01802"
beetSugarCode = "23512"
caneSugarCode = "23511.01"
refinedSugarCode = "23520"
molassesCode = "23540"

currentCountry = "840"
currentYear = "2011"

# Never use scientific notation.
options(scipen = 100)
# options(digits = 0)

if(Sys.info()[7] == "josh"){ # Josh Work
    workingDir = "~/Documents/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] %in% c("browningj", "rockc_000")){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else if(Sys.info()[7] == "Golini"){ # Josh virtual & home
    workingDir = "~/Github/privateFAO/OrangeBook/"
} else {
    stop("No working dir for current user!")
}

## Source AUPUS files
files = dir(paste0(workingDir, "../../faoswsAupus/R"), full.names = TRUE)
## Assign to temp so as to prevent writing to screen
temp = sapply(files, source)
source(paste0(workingDir, "printTableFunctions.R"))
source(paste0(workingDir, "replaceData.R"))
source(paste0(workingDir, "../../Balancing_ML/R/balancing.R"))
source(paste0(workingDir, "../../Balancing_ML/R/forceBalance.R"))

params = defaultStandardizationParameters()
    
fbsElements = c(params$productionCode, params$feedCode, params$seedCode,
                params$wasteCode, params$foodCode, params$stockCode,
                params$importCode, params$exportCode, params$foodProcCode)
wheatKeys = c("0111", "23110", "23140.01", "23140.02", "23140.03", "23220.01",
              "23220.02", "23490.02", "23710", "39120.01", "F0020", "F0022")
cattleKeys = c("02111", "21111.01", "21111.02", "21182", "21184.01", "21185",
               "21512.01", "23991.04", "F0875")
palmOilKeys = c("01491.02", "2165", "21691.14", "21910.06", "21700.01",
                "21700.02", "F1243", "34550", "F1275", "34120")
sugarKeys = c("01802", "23512", "F7156", "23210.04", "2351", "23511", "23520",
              "23540", "23670.01", "24110", "2413", "24131", "24139",
              "24490.92", "39140.02", "F7157", "01801", "39140.01", "F7161",
              "01809", "F7162", "F7163")
milkKeys = c("02211", "22110.01", "22110.02", "22110.03", "22211", "22212",
             "22221.01", "22221.02", "22222.01", "22222.02", "22230.01",
             "22230.02", "22230.03", "22230.04", "22241.01", "22241.02",
             "22251.01", "22251.02", "22251.03", "2251.04", "22260",
             "23210.06")
fullData = fread(paste0(workingDir, "standardizationData.csv"))
fullData = fullData[timePointYears == currentYear &
                        geographicAreaM49 == currentCountry, ]
## Coerce food from logical (default since all NA) to numeric
foodVar = paste0(params$elementPrefix, params$foodCode)
fullData[, c(foodVar) := as.numeric(get(foodVar))]
## Set up empty variable for stock changes
stockVar = paste0(params$elementPrefix, params$stockCode)
fullData[, c(stockVar) := NA_real_]
## Set up empty variable for food processing
foodProcVar = paste0(params$elementPrefix, params$foodProcCode)
fullData[, c(foodProcVar) := NA_real_]
## Set up empty variable for industrial utilization
indVar = paste0(params$elementPrefix, params$industrialCode)
fullData[, c(indVar) := NA_real_]
## Set up empty variable for tourist consumption
touVar = paste0(params$elementPrefix, params$touristCode)
fullData[, c(touVar) := NA_real_]

pulledElements = c("5113", "5025", "5312", "5510", "5421", "5520", "5525",
                   "5023", "5327", "5016", "5141", "5120", "f???")

tree = fread(paste0(workingDir, "standardizationTree.csv"),
             colClasses = c("character", "character", "numeric", "character",
                            "numeric", "character", "numeric"))
## Don't want infinite extraction rates until standardization, so just make up
## some
## Butcher fat to cattle meat
tree[parentID == "21111.01" & childID == "21512.01", extractionRate := 0.05]
## Cake of palm kernels to palm kernels
tree[parentID == "01491.02" & childID == "21910.06", extractionRate := 0.10]
## Gluten to flour
tree[parentID == "23110" & childID == "23220.02", extractionRate := 0.5]
## Conversion to CPC was slightly problematic: Beet sugar gets processed into 
## element "23510" for which we have no data (and the CPC code doesn't seem to 
## exist in the online UN directory: 
## http://unstats.un.org/unsd/cr/registry/docs/CPCv2_structure.pdf.  So, Beet
## sugar and Cane sugar will be processed directly to Refined sugar (for the
## purpose of this example at least).
tree = tree[!parentID == "23510" & !childID == "23510", ]
tree = rbindlist(list(tree,
                      data.table(childID = "23520", target = "B",
                                 extractionRate = 0.92,
                                 parentID = c(23511.01, 23512),
                                 calorieExtractionRate = 1,
                                 groupID = c("23511.01-23520", "23512-23520"))),
                 fill = TRUE)
edges = tree[(parentID %in% sugarKeys | childID %in% sugarKeys) &
                 !is.na(parentID) & !is.na(childID), ]

itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))

## Avoid printing all the data.table's
sink("temp.txt")
sapply(pulledElements, function(el){
    val = paste0("Value_measuredElement_", el)
    oFl = paste0("flagObservationStatus_measuredElement_", el)
    mFl = paste0("flagMethod_measuredElement_", el)
    fullData[is.na(get(val)), c(oFl) := "M"]
    fullData[is.na(get(val)), c(mFl) := "u"]
    fullData[is.na(get(val)), c(val) := 0]
    ## A bit hackish, but use "" flags if NA
    fullData[is.na(get(oFl)), c(oFl) := ""]
    fullData[is.na(get(oFl)), c(mFl) := ""]
})
sink()
})})
```

## Wheat

For this example, we'll first consider the full process for creating a food balance sheet for wheat.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
wheatData = fullData[measuredItemCPC %in% wheatKeys, ]
wheatData = data.table:::melt.data.table(data = wheatData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
wheatData[grepl("Value", variable), variableType := "Value"]
wheatData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
wheatData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = wheatData, formula = as.formula(castFormula),
#                             value.var = "value")
wheatData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(wheatData, "variable", "element")
wheatData = tidyr::spread(data = wheatData, key = "variableType", value = "value")
## Remove alot of the data, and "impute" it later
wheatData[, Value := rep(0, nrow(wheatData))]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  To impute production, we must also consider yield and area harvested data as yield is defined as production divided by area harvested (and thus with any two elements the third is uniquely defined).  Suppose we have the following official data:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
    
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear &
                        measuredItemCPC %in% c("0111", "23110"), ]
## Force wheat to be missing except for area harvested
toPrint[measuredItemCPC == "0111" & element %in% c("5510", "5421"), Value := 0]
toPrint[measuredItemCPC == "0111" & element == "5312", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5312]]
## Force flour to be missing except for production
toPrint[measuredItemCPC == "23110" & element %in% c("5312", "5421"), Value := NA]
toPrint[measuredItemCPC == "23110" & element == "5510", Value := 
    fullData[measuredItemCPC == "23110" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

In this case, the production value is only known for wheat flour (it is missing for wheat), and for wheat we are also missing the yield value.  The first step in the imputation process is to impute the yield, using the previously described production imputation methodology.

ADD SOMETHING HERE SHOWING THE IMPUTATION EXAMPLE!!!

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5421", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5421]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

Now, we have enough information to compute the production data:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

## "Impute" by extracting the official yield value
toPrint[measuredItemCPC == "0111" & element == "5510", Value := 
    fullData[measuredItemCPC == "0111" & timePointYears == currentYear &
                 geographicAreaM49 == currentCountry, Value_measuredElement_5510]]
printProductionTable(toPrint, params, workingDir = workingDir)

})})
```

```{r, echo = FALSE}
suppressWarnings({suppressMessages({invisible({
wheatData = merge(wheatData,
                  fullData[measuredItemCPC %in% wheatKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
wheatData[element == "5510", Value := Value_measuredElement_5510]
wheatData[, standardDeviation := 0]
wheatData[element == "5510" & measuredItemCPC == "0111",
          standardDeviation := Value * .01]
wheatData[element == "5510" & Value == 0, Value := NA]
wheatData[, Value_measuredElement_5510 := NULL]
})})})
```

Next, we fill in the table with our production values.  Production is only imputed for primary products (and occassionally official figures are provided for processed products, as is the case here).  So, in this case, no additional values are filled in outside of wheat and flour.

```{r, echo = FALSE, fig.show = FALSE}
suppressWarnings({suppressMessages({

# procParams = defaultProcessingParameters(productionValue = 5510,
#                                          yieldValue = 5421,
#                                          areaHarvestedValue = 5312)
# yieldParams = defaultImputationParameters(variable = 5421)
# prodIParams = defaultImputationParameters(variable = 5510)
# # procParams$byKey <- yieldParams$byKey <- prodIParams$byKey <-
# #     c("geographicAreaM49", "measuredItemCPC")
# yieldParams$estimateNoData <- prodIParams$estimateNoData <- TRUE
# imputeProductionDomain(data = wheatData[measuredItemCPC == "0111", ],
#                        processingParameters = procParams,
#                        yieldImputationParameters = yieldParams,
#                        productionImputationParameters = prodIParams)
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

For this example, we take the country totals of all imports and exports and insert into this table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
wheatData = replaceData(wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% wheatKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
wheatData = replaceData(wheatData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
wheatData[element == "5600" & measuredItemCPC == "23140.02" &
              timePointYears == "2011", Value := 182485]
wheatData[element == "5900" & measuredItemCPC == "23140.03" &
              timePointYears == "2011", Value := 217289]
wheatData[element == "5600" & Value == 0, Value := NA]
wheatData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
wheatData = wheatData[geographicAreaM49 == currentCountry, ]
# params$mergeKey = params$mergeKey[2:3]

toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

### Stock Changes

We now estimate the stock changes.  Note that for most products, we assume that countries do not hold stocks.  Generally, stocks will only be held for primary level products, and not even all of these products.  The numbers below represent the estimated stock changes (by the stock imputation methodology described previously) for the example country we're considering.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
wheatData = replaceData(wheatData,
    stockEstimates[, c("Value_measuredElement_71",
                       "standardDeviation_measuredElement_71",
                       params$mergeKey),
                   with = FALSE],
    mergeKey = params$mergeKey)
wheatData[element == "71" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The allocation to food, on the other hand, can potentially be considered at any processing level, although some commodities (such as wheat) are assumed to not be eaten as such.  We impute food consumption numbers for the example country and update the SUA table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
wheatData = replaceData(wheatData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# wheatData[element == "5141" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141"]
printTable(toPrint, params, workingDir)
})})
```


### Feed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/feedEstimates.RData"))
## Hack the feed estimate for bran to make the example work better
feedEstimates[measuredItemCPC == branCode, Value_measuredElement_5520 := 3355525]
feedEstimates[, standardDeviation_measuredElement_5520 :=
                  Value_measuredElement_5520 * .05]
wheatData = replaceData(wheatData,
            feedEstimates[, c("Value_measuredElement_5520",
                               "standardDeviation_measuredElement_5520",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5520" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
wheatData = replaceData(wheatData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5120" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, Value_measuredElement_5525 := seedPredicted]
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  exp(seedVariance)]
wheatData = replaceData(wheatData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "5525" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

For most commodities, industrial utilization will be zero.  This element can be important when considering commodities related to biofuels and vegetable oils, but for wheat it is irrelevant.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
wheatData = replaceData(wheatData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "i???" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the WTO as well as last year's consumption patterns to estimate the impact of tourism on local consumption.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, the country will have a negative ``tourist consumption'' because more calories will be consumed abroad than locally.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates[, standardDeviation_measuredElement_tou :=
                     abs(Value_measuredElement_tou) * .1]
setnames(touristEstimates, "Value_measuredElement_tou",
         "Value_measuredElement_t???")
setnames(touristEstimates, "standardDeviation_measuredElement_tou",
         "standardDeviation_measuredElement_t???")
wheatData = replaceData(wheatData,
            touristEstimates[, c("Value_measuredElement_t???",
                                 "standardDeviation_measuredElement_t???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
wheatData[element == "t???" & Value == 0, Value := NA]
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "t???"]
printTable(toPrint, params, workingDir)
})})
```

### Standardization and Balancing

Now, suppose we have the following commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
edges = tree[parentID %in% wheatKeys, ]
setnames(itemName, "Item", params$parentVar)
edges = merge(edges, itemName, by = params$parentVar, all.x = TRUE)
edges[, c("parentID", "Name") := list(Name, NULL)]
setnames(itemName, params$parentVar, params$childVar)
edges = merge(edges, itemName, by = params$childVar, all.x = TRUE)
edges[, c("childID", "Name") := list(Name, NULL)]
edges[, childID := gsub(" ", "\n", childID)]
edges[, parentID := gsub(" ", "\n", parentID)]
setnames(itemName, params$childVar, "Item")
plotSingleTree(edges = edges, parentColname = "parentID",
               childColname = "childID", extractionColname = "extractionRate",
               box.size = .08, box.type = "circle", cex.txt = 2, box.prop = .5,
               box.cex = 1.9)
})})
```

We first start with the pre-standardized table:

```{r, echo = FALSE}
# save(wheatData, file = paste0(workingDir, "preStandardizedWheat.RData"))
# load(paste0(workingDir, "preStandardizedWheat.RData"))
suppressWarnings({suppressMessages({
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

We then compute the required ``production'' of each of the processed products to satisfy any deficits due to exports or consumption (note that we can allow production to be zero if supply exceeds utilization).

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
## Production = Exports + Food - Imports
## 5510 = 5900 + 71 - 5600
computeProcessedProduction(data = wheatData, tree = tree, standParams = params)
wheatData[element == "5510" & Value < 0, Value := 0]
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := (element == "5510" & Value < 18000000)]
printTable(toPrint, params, workingDir)
})})
```

Since wheat starch is produced from wheat flour, we would first need to ensure the wheat flour "food to processing" can cover any deficits of wheat starch.  However, since wheat starch imports exceed exports plus food, we don't have to worry about this requirement.  Instead, we can just standardize all the first processed level products back to food to processing of wheat.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
distributionTable = toPrint[measuredItemCPC %in% c(flourCode, bulgurCode,
                                                   cerealsCode, branCode) &
                                element == params$productionCode,
                            list(measuredItemCPC, Value, standardDeviation)]
setnames(distributionTable, c("Item", "prodMean", "prodSd"))
distributionTable[, wheatMean := prodMean / c(.72, .95, 1, .22)]
distributionTable[, wheatSd := prodSd / c(.72, .95, 1, .22)]
printStandardizationTable(distributionTable, params, workingDir = workingDir)
})})
```

Now, we wish to compute the distribution for the "food to processing" element for wheat.  The main requirement is in the wheat flour and bran, and it should be noted that the 26 million kilogram requirement for wheat flour will automatically be satisfied if the 35 million kilogram requirement for wheat bran is satisfied (as they are produced together).  Thus, the food to processing element for wheat has a mean of 35 million kilograms (the sum of the last three) and a standard deviation of 2.55 million kilograms (the square-root of the sum of the squares of the last three standard deviations).  Thus, we now have the following table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
wheatData = rollUpFood(data = wheatData, tree = tree, standParams = params)
toPrint = wheatData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := (element == params$foodProcCode &
                             measuredItemCPC == "0111")]
printTable(toPrint, params, workingDir)
})})
```

Now, we must balance this table.  To do this, we need to extract the computed standard deviations of each element.  The table below shows the expected value and estimated standard deviation for each of the elements for wheat:

```{r, echo = FALSE}
invisible(toPrint[, updateFlag := NULL])
toPrint = toPrint[measuredItemCPC == "0111", ]
printDistributionTable(toPrint, params)
```

Note that in this case, the standard deviation for food for processing is very small because the flour production is an official figure (and this is the main use of wheat).  Thus, the "food for processing" element is not adjusted much.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
toPrint = toPrint[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
sink("temp.txt") # Sink balancing output so it doesn't get printed.
toPrint[, balancedValue := balancing(param1 = sapply(Value, na2zero),
              param2 = sapply(standardDeviation, na2zero),
              sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
              lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
              optimize = "constrOptim", constrTol = 1e-2)]
sink()
toPrint[, adjustment := balancedValue - Value]
wheatData = merge(wheatData,
                  toPrint[, !c("Value", "metFlag", "obsFlag", "standardDeviation"),
                          with = FALSE],
                  by = c(params$mergeKey, "element"), all.x = TRUE)
wheatData[!is.na(balancedValue), Value := balancedValue]
wheatData[, balancedValue := NULL]
toPrint[, Value := balancedValue]
toPrint[, c("adjustment", "balancedValue") := NULL]
printDistributionTable(toPrint, params)
})})
```

Now, when balancing, we find that food for processing is adjusted down slightly.  This adjustment to food of wheat implies that the production of children commodities must also be updated (and hence their food values as well).

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
foodDelta = -wheatData[measuredItemCPC == "0111" & timePointYears == "2011" &
                  element == params$foodProcCode, get(params$adjustVar)]
## Determine adjustment by balancing: change(first element) + change(second) +
## ... = total change, so we have an equation to balance.
sink("temp.txt") # Prevent writing balancing output to document
distributionTable[2:4, adjustment :=
    ## Means should all be 0, as we're looking at deltas from original values.
    balancing(param1 = c(rep(0, .N), foodDelta),
              ## Standard deviations can be read directly, and the 
              ## difference is assumed to be fixed.
              param2 = c(wheatSd, 0),
              sign = rep(1, .N+1),
              lbound = rep(-Inf, .N+1),
              optimize = "constrOptim",
              constrTol = 1e-4)[1:.N]]
sink()
distributionTable[is.na(adjustment), adjustment := 0]
distributionTable[, wheatMean := wheatMean + adjustment]
distributionTable[, prodMean := prodMean + adjustment * c(.72, .95, 1, .22)]
printStandardizationTable(distributionTable, params, workingDir = workingDir)
})})
```

We can now update the production numbers for each of the first level primary elements.  Note that in the process of creating flour, we also create bran and germ.  The amount of bran and germ created, in this case, is determined by the amount of flour we need to create (as that was our most stringent requirement).  Thus, we have:

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
## Add in default shares for all processing activities
invisible({
tree[, share := NA_real_]
tree[groupID == "0111-23110", share := .90]
tree[groupID == "0111-23140.02", share := .05]
tree[groupID == "0111-23140.03", share := .05]
})
## Allocate down the adjustments in the true/automated way
# save(wheatData, file = paste0(workingDir, "StandardizedWheat1.RData"))
# load(paste0(workingDir, "StandardizedWheat1.RData"))
sink("temp.txt") # Sink balancing output so it doesn't get printed.
wheatData = rollDownFoodDelta(data = wheatData, tree = tree,
                              standParams = params,
                              feedElements = c("23140.01", "39120.01"))
sink()
toPrint = wheatData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, adjustment := NULL]
toPrint[, updateFlag := (measuredItemCPC == germCode) |
            (element %in% c(params$foodCode, params$productionCode, params$feedCode) &
                 measuredItemCPC %in% c(bulgurCode, germCode, cerealsCode, branCode) &
                 Value > 0)]
printTable(toPrint, params, workingDir)
})})
```
 
Our food balance sheet is nearly completed, except that some commodities haven't been handled yet.  In particular, wheat starch had imports exceeding exports and so we have not balanced that commodity yet; also, wheat flour has official production and so we haven't modified that commodity either.  These unbalanced elements must be updated, and since the production is already fixed (either because it's an official figure or because it's 0) the balancing is very straight-forward: the uncertainty will be entirely allocated to food (or, in general, to either food or feed).

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
finalSuaBalance(wheatData, standParams = params,
                feedElements = c(branCode, germCode))
toPrint = wheatData[timePointYears == "2011", ]
toPrint[, updateFlag := element == params$foodCode &
            measuredItemCPC %in% c(starchCode, flourCode)]
printTable(toPrint, params, workingDir)
})})
```

Now, the final step is aggregating this full table back into primary equivalent.  For most elements, this is trivial: for example, the final stock change for wheat will simply be the current stock change because there is no stock change for processed products.  However, there are three elements that must be handled differently: imports, exports, and food.  Note that the final value for wheat equivalent production is simply the current value for wheat production: this is because ``production'' of flour (or any other processed product) isn't really production in the sense that the flour is acquired from a different commodity (whereas production of wheat is truly a production as it is not derived from anything else).  Also, food processing will not be standardized as it is more of an accounting variable that specifies how much of a commodity at one level should be processed into a different commodity.

To standardize trade and food, we can simply aggregate the trade and food of the children commodities up into their primary equivalent by dividing by the extraction rate.  We add these primary equivalents to the current value of trade/food of wheat, and we have our final, primary equivalent trade/food of wheat.  Also, feed is not standardized back into wheat equivalent as it is accounted for **???**.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
params$elementPrefix = ""
invisible({
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[, share := 1]
## Don't standardize back germ and bran
standTree[parentID == "0111" & childID == "39120.01", extractionRate := Inf]
standTree[parentID == "0111" & childID == "23140.01", extractionRate := Inf]
})
params$elementPrefix = ""
finalValues = finalStandardizationToPrimary(data = wheatData, tree = standTree,
                                            standParams = params)
finalValues = finalValues[timePointYears == "2011", ]
printTable(finalValues, standParams = params, workingDir)
})})
```

We can also compute calories, fats, and proteins at this point.  First, we apply a calorie/fat/protein content factor to each individual element:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

load(paste0(workingDir, "nutrientData.RData"))
# Loads object "nutrientData"
    
toPrint = wheatData[timePointYears == "2011" & element == params$foodCode, ]
toPrint = merge(toPrint, nutrientData, by = params$itemVar, all.x = TRUE)

setnames(itemName, "Item", params$itemVar)
toPrint = merge(toPrint[, c(params$itemVar, "Value", "Protein", "Fat", "Energy"),
                        with = FALSE], itemName, all.x = TRUE)
setnames(itemName, params$itemVar, "Item")
toPrint[, measuredItemCPC := NULL]

setcolorder(toPrint, c("Name", "Value", "Energy", "Protein", "Fat"))
setnames(toPrint, "Value", "Quantity")
knitr::kable(toPrint)

})})
```

Standardization is trivial: all the commodities here are purely additive, so the standardized calories/fats/proteins are simply the sum of the total calories/fats/proteins for each element:

```{r, echo = FALSE}
out = toPrint[, list(
    Energy  = sum(Quantity * Energy , na.rm = TRUE)/1000000,
    Protein = sum(Quantity * Protein, na.rm = TRUE)/1000000,
    Fat     = sum(Quantity * Fat    , na.rm = TRUE)/1000000), by = ""]
out = round(out, 2)
setnames(out, colnames(out), paste(colnames(out), "(millions)"))
knitr::kable(out)
```

```{r, echo = FALSE}
## We're done with wheat, so let's remove that data to make sure we don't
## reference it later on accident.
rm(wheatData)
```
















## Sugar

Now, let's consider the full process for creating a food balance sheet for sugar.  We start off with an empty table:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = fullData[measuredItemCPC %in% sugarKeys, ]
sugarData = data.table:::melt.data.table(data = sugarData,
    id.vars = c(params$geoVar, params$itemVar, params$yearVar))
sugarData[grepl("Value", variable), variableType := "Value"]
sugarData[grepl("flagObservationStatus", variable), variableType := "obsFlag"]
sugarData[grepl("flagMethod", variable), variableType := "metFlag"]
castFormula = paste(paste(params$mergeKey, collapse = " + "), "~ variableType")
# temp = tidyr::spread(data = sugarData, formula = as.formula(castFormula),
#                             value.var = "value")
sugarData[, variable := gsub("[A-Za-z_]*_", "", variable)]
setnames(sugarData, "variable", "element")
sugarData = tidyr::spread(data = sugarData, key = "variableType", value = "value")
## Remove alot of the data, and "impute" it later
sugarData[, Value := rep(0, nrow(sugarData))]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

### Production

For production data, we first fill in the table with any available official figures.  In this case, the production value is known for all the primary products and thus no imputation is done.  We also have production data for some of the processed commodities:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
sugarData = merge(sugarData,
                  fullData[measuredItemCPC %in% sugarKeys,
                           c("Value_measuredElement_5510", params$mergeKey),
                           with = FALSE], by = params$mergeKey)
sugarData[element == "5510", Value := Value_measuredElement_5510]
sugarData[, standardDeviation := 0]
sugarData[element == "5510" & Value == 0, Value := NA]
sugarData[, Value_measuredElement_5510 := NULL]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5510"]
printTable(toPrint, params, workingDir)

})})
```

### Trade

For the next example, we'll show how the imputation, mirroring and balancing works.  In this case, we just take the country totals and insert into this table.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5600", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5600 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
newTradeData = fullData[measuredItemCPC %in% sugarKeys,
                        c("Value_measuredElement_5900", params$mergeKey),
                        with = FALSE]
newTradeData[, standardDeviation_measuredElement_5900 := 0]
sugarData = replaceData(originalData = sugarData, newData = newTradeData,
            mergeKey = params$mergeKey)
## Manually tweak trade to create a deficit.  Makes standardization more
## interesting later.
# sugarData[element == "5600" & measuredItemCPC == "23140.02" &
#               timePointYears == "2011", Value := 182485]
# sugarData[element == "5900" & measuredItemCPC == "23140.03" &
#               timePointYears == "2011", Value := 217289]
sugarData[element == "5600" & Value == 0, Value := NA]
sugarData[element == "5900" & Value == 0, Value := NA]

## No longer need other countries, so drop them!
sugarData = sugarData[geographicAreaM49 == currentCountry, ]
# params$mergeKey = params$mergeKey[2:3]

toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element %in% c("5600", "5900")]
## Print the trade data
printTable(toPrint, params, workingDir)
})})
```

### Stock Changes

We now estimate the stock changes.  Note that for most products, we assume that countries do not hold stocks.  Generally, stocks will only be held for primary level products, and not even all of these products.  The numbers below represent the estimated stock changes (by the stock imputation methodology described previously) for the example country we're considering.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/stockEstimates.RData"))
setnames(stockEstimates, c("Value", "sdEstimate"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_71"))
sugarData = replaceData(sugarData,
            stockEstimates[, c("Value_measuredElement_71",
                               "standardDeviation_measuredElement_71",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "71" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, updateFlag := element == "71"]
printTable(toPrint, params, workingDir)
})})
```

### Food

The allocation to food, on the other hand, can potentially be considered at any processing level, although some commodities (such as wheat) are assumed to not be eaten as such.  We impute food consumption numbers for the example country and update the FBS table below.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/foodEstimates.RData"))
setnames(foodEstimates, c("mean", "var"),
         paste0(c("Value", "standardDeviation"), "_measuredElement_5141"))
foodEstimates = foodEstimates[geographicAreaM49 == "840", ]
sugarData = replaceData(sugarData,
            foodEstimates[, c("Value_measuredElement_5141",
                               "standardDeviation_measuredElement_5141",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
# If no food is estimated yet, it doesn't mean that it should be forced to be 0.
# sugarData[element == "5141" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5141" & Value > 0]
printTable(toPrint, params, workingDir)
})})
```

### Feed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "feedEstimates.RData"))
feedEstimates[, standardDeviation_measuredElement_5520 :=
                  Value_measuredElement_5520 * .1]
sugarData = replaceData(sugarData,
            feedEstimates[, c("Value_measuredElement_5520",
                               "standardDeviation_measuredElement_5520",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5520" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5520"]
printTable(toPrint, params, workingDir)
})})
```

### Losses

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/lossEstimates.RData"))
lossEstimates[, standardDeviation_measuredElement_5120 :=
                  Value_measuredElement_5120 * .1]
sugarData = replaceData(sugarData,
            lossEstimates[, c("Value_measuredElement_5120",
                               "standardDeviation_measuredElement_5120",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5120" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5120"]
printTable(toPrint, params, workingDir)
})})
```

### Seed

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/seedEstimates.RData"))
seedEstimates[, standardDeviation_measuredElement_5525 :=
                  Value_measuredElement_5525 * .1]
sugarData = replaceData(sugarData,
            seedEstimates[, c("Value_measuredElement_5525",
                               "standardDeviation_measuredElement_5525",
                               params$mergeKey),
                           with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "5525" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "5525"]
printTable(toPrint, params, workingDir)
})})
```

### Industrial Utilization

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/industrialEstimates.RData"))
industrialEstimates[, standardDeviation_measuredElement_ind :=
                        Value_measuredElement_ind * .1]
setnames(industrialEstimates, "Value_measuredElement_ind",
         "Value_measuredElement_i???")
setnames(industrialEstimates, "standardDeviation_measuredElement_ind",
         "standardDeviation_measuredElement_i???")
sugarData = replaceData(sugarData,
            industrialEstimates[, c("Value_measuredElement_i???",
                                    "standardDeviation_measuredElement_i???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "i???" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "i???"]
printTable(toPrint, params, workingDir)
})})
```

### Tourist Consumption

The tourist consumption estimation approach uses tourist data from the WTO as well as last year's consumption patterns to estimate the impact of tourism on local consumption.  Note that tourist consumption can be negative; as an extreme example consider a case where many nationals travel abroad but no tourists enter.  In this case, the country will have a negative ``tourist consumption'' because more calories will be assumed abroad than locally.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
load(paste0(workingDir, "/touristEstimates.RData"))
touristEstimates[, standardDeviation_measuredElement_tou :=
                     abs(Value_measuredElement_tou) * .1]
setnames(touristEstimates, "Value_measuredElement_tou",
         "Value_measuredElement_t???")
setnames(touristEstimates, "standardDeviation_measuredElement_tou",
         "standardDeviation_measuredElement_t???")
sugarData = replaceData(sugarData,
            touristEstimates[, c("Value_measuredElement_t???",
                                 "standardDeviation_measuredElement_t???",
                                    params$mergeKey),
                                with = FALSE],
            mergeKey = params$mergeKey)
sugarData[element == "t???" & Value == 0, Value := NA]
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := element == "t???"]
printTable(toPrint, params, workingDir)
})})
```
### Standardization and Balancing

Now, suppose we have the following commodity tree:

```{r, echo = FALSE, fig.height=12, fig.width = 18}
suppressWarnings({suppressMessages({
edges = tree[childID %in% sugarKeys | parentID %in% sugarKeys, ]
itemName = fread(paste0(workingDir, "elementDescription.csv"),
                 colClasses = c("character", "character"))
setnames(itemName, "Item", params$parentVar)
edges = merge(edges, itemName, by = params$parentVar, all.x = TRUE)
edges[, c("parentID", "Name") := list(Name, NULL)]
setnames(itemName, params$parentVar, params$childVar)
edges = merge(edges, itemName, by = params$childVar, all.x = TRUE)
edges[, c("childID", "Name") := list(Name, NULL)]
edges[, childID := gsub(" ", "\n", childID)]
edges[, parentID := gsub(" ", "\n", parentID)]
plotSingleTree(edges = edges,
               parentColname = "parentID", childColname = "childID",
               extractionColname = "extractionRate", box.size = .06,
               box.type = "circle", cex.txt = 2, box.prop = .5, box.cex = 1.9)
})})
```

We first start with the pre-standardized table:

```{r, echo = FALSE}
# save(sugarData, tree, file = paste0(workingDir, "preStandardizedSugar.RData"))
# load(paste0(workingDir, "preStandardizedSugar.RData"))
suppressWarnings({suppressMessages({
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

The processing for sugar works slightly differently than most commodities.  Sugar cane and sugar beet are, in almost every case, converted into cane sugar or beet sugar (i.e. they are not eaten as such nor are they processed into other products).  Thus, in this case, rather than standardizing values back to sugar cane and sugar beet, we instead assume all sugar cane and sugar beet is first converted into the corresponding sugar and we perform the balances at this level.

```{r, echo = FALSE}
suppressWarnings({suppressMessages({
output = processForward(sugarData, tree, standParams = params)
sugarData = output$data
tree = output$tree
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
printTable(toPrint, params, workingDir)
})})
```

The next step in this process is to balance the processed commodities by creating production values.  These production values will require an amount of food processing from the parent commodities.  We must start this process at the bottom of the tree, in this case considering "Sugar and Syrups nes" and "Sugar Confectionary" and going up to "Refined Sugar".

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

# Manually input the production/food processing values to show the process.
toPrint[, tempProd := sum(Value *
    ifelse(element %in% c(params$exportCode, params$stockCode, params$foodCode,
                          params$foodProcCode, params$feedCode, params$wasteCode,
                          params$seedCode, params$industrialCode, params$touristCode,
                          params$residualCode), 1,
           ifelse(element == params$importCode, -1, 0)), na.rm = TRUE),
    by = c(params$mergeKey)]
invisible(toPrint[measuredItemCPC == 23210.04 &
            element == params$productionCode,
        c("Value", "updateFlag") := list(tempProd, TRUE)])
invisible(toPrint[measuredItemCPC == 23520 &
            element == params$foodProcCode,
        c("Value", "updateFlag") := list(
            toPrint[measuredItemCPC == 23210.04 &
                        element == params$productionCode, Value], TRUE)])
printTable(toPrint, params, workingDir)
})})
```

Next, we move up the tree to the balancing of refined sugar and the food processing required in the beet and cane sugar elements.  We require refined sugar production in order to balance refined sugar, and thus we must create this production from the parent(s) of refined sugar.  Looking at the commodity tree, we see that refined sugar can be created from both beet and cane sugar.  We will allocate production of refined sugar from these parent commodities according to their availabilities.

```{r, echo = FALSE}
temp = data.frame(Name = c("Beet sugar", "Cane sugar, centrifugal"),
                  Availability = c(4561000+27245-194848,
                                   2916276+1070-95-23458),
                  Percent = c(4393397/(4393397+2893793), 2893793/(4393397+2893793)))
temp$Percent = paste0(round(temp$Percent, 3)*100, "%")
knitr::kable(temp, align = c("r", "r", "r"))
```

Thus, we allocate according to the parent availabilities:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

toPrint[, updateFlag := FALSE]
# Manually input the production/food processing values to show the process.
toPrint[, tempProd := sum(Value *
    ifelse(element %in% c(params$exportCode, params$stockCode, params$foodCode,
                          params$foodProcCode, params$feedCode, params$wasteCode,
                          params$seedCode, params$industrialCode, params$touristCode,
                          params$residualCode), 1,
           ifelse(element == params$importCode, -1, 0)), na.rm = TRUE),
    by = c(params$mergeKey)]
invisible(toPrint[measuredItemCPC == 23520 &
            element == params$productionCode,
        c("Value", "updateFlag") := list(tempProd, TRUE)])
invisible(toPrint[measuredItemCPC == beetSugarCode &
            element == params$foodProcCode,
        c("Value", "updateFlag") := list(
            toPrint[measuredItemCPC == 23520 &
                        element == params$productionCode, Value]/.92 * .603, TRUE)])
toAppend = toPrint[1, ]
toAppend[, c(params$itemVar, "element", "Value", "updateFlag") :=
             list(caneSugarCode, params$foodProcCode, 
                  toPrint[measuredItemCPC == 23520 &
                              element == params$productionCode, Value]/.92 * .397,
                  TRUE)]
toPrint = rbind(toPrint, toAppend)
printTable(toPrint, params, workingDir)
})})
```

```{r, echo = FALSE}
## Now, do all the stuff you did above, plus compute the aggregated standard
## errors, in a more rigorous way:
invisible({suppressWarnings({suppressMessages({
sugarData = rollUpFood(data = sugarData, tree = tree, standParams = params)
toPrint = sugarData[geographicAreaM49 == currentCountry &
                        timePointYears == currentYear, ]
toPrint[, updateFlag := (element == params$foodProcCode & Value > 0)]
})})})
```

```{r, echo = FALSE, eval = FALSE}
## Set eval to TRUE to verify the two processes give the same result.
printTable(toPrint, params, workingDir)
```

Now, we must balance the primary products in this table (i.e. sugar cane and sugar beet).  To do this, we need to extract the computed standard deviations of each element.  The table below shows the expected value and estimated standard deviation for sugar beet (top) and sugar cane (bottom):

```{r, echo = FALSE}
toPrintBeet = toPrint[measuredItemCPC == beetSugarCode, ]
printDistributionTable(toPrintBeet, params)
toPrintCane = toPrint[measuredItemCPC == caneSugarCode, ]
toPrintCane = rbindlist(list(toPrintCane,
        data.table(geographicAreaM49 = 840, timePointYears = 2011,
                   measuredItemCPC = 23511.01,
                   element = c(params$feedCode, params$seedCode,
                               params$wasteCode, params$foodCode,
                               params$stockCode, params$importCode,
                               params$exportCode, params$industrialCode,
                               params$touristCode))), fill = TRUE)
printDistributionTable(toPrintCane, params)
```

After balancing the above tables, we're left with the following values.  Note that only waste and food processing are adjusted, and food processing takes the majority of the change because it has a substantially higher variability.

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
toPrintBeet = toPrintBeet[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
toPrintCane = toPrintCane[element %in% c(params$productionCode, params$exportCode,
                                 params$importCode, params$stockCode,
                                 params$foodCode, params$feedCode,
                                 params$wasteCode, params$seedCode,
                                 params$industrialCode, params$touristCode,
                                 params$residualCode, params$foodProcCode), ]
toPrintBeet[is.na(Value), Value := 0]
toPrintCane[is.na(Value), Value := 0]
toPrintBeet[is.na(standardDeviation), standardDeviation := 0]
toPrintCane[is.na(standardDeviation), standardDeviation := 0]
sink("temp.txt") # Sink balancing output so it doesn't get printed.
toPrintBeet[, balancedValue := balancing(param1 = Value, param2 = standardDeviation,
          sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
          lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
          optimize = "constrOptim")]
toPrintCane[, balancedValue := balancing(param1 = Value, param2 = standardDeviation,
          sign = ifelse(element %in% c(params$productionCode, params$importCode), 1, -1),
          lbounds = ifelse(element %in% params$stockCode, -Inf, 0),
          optimize = "constrOptim")]
sink()
toPrintBeet[, adjustment := balancedValue - Value]
toPrintCane[, adjustment := balancedValue - Value]
sugarData = merge(sugarData,
                  rbind(toPrintBeet, toPrintCane)[, c(params$mergeKey, "element",
                                                      "balancedValue", "adjustment"),
                                                  with = FALSE],
                  by = c(params$mergeKey, "element"), all.x = TRUE)
sugarData[!is.na(balancedValue), Value := balancedValue]
sugarData[, balancedValue := NULL]
toPrintBeet[, Value := balancedValue]
toPrintCane[, Value := balancedValue]
toPrintBeet[, c("adjustment", "balancedValue") := NULL]
toPrintCane[, c("adjustment", "balancedValue") := NULL]
printDistributionTable(toPrintBeet, params)
printDistributionTable(toPrintCane, params)
})})
```

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
## Allocate down the adjustments in the true/automated way
# save(sugarData, tree, file = paste0(workingDir, "standardizedSugar1.RData"))
# load(paste0(workingDir, "standardizedSugar1.RData"))
sink("temp.txt") # Sink balancing output so it doesn't get printed.
sugarData = rollDownFoodDelta(data = sugarData, tree = tree,
                              standParams = params,
                              feedElements = c("23140.01", "39120.01"))
sink()
toPrint = sugarData[geographicAreaM49 == currentCountry & timePointYears == currentYear, ]
toPrint[, adjustment := NULL]
toPrint[, updateFlag := (measuredItemCPC == germCode) |
            (element %in% c(params$foodCode, params$productionCode, params$feedCode) &
                 measuredItemCPC %in% c(bulgurCode, germCode, cerealsCode, branCode) &
                 Value > 0)]
printTable(toPrint, params, workingDir)
})})
```

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
finalSuaBalance(sugarData, standParams = params,
                feedElements = c(branCode, germCode))
toPrint = sugarData[timePointYears == "2011", ]
toPrint[, updateFlag := element == params$foodCode &
            measuredItemCPC %in% c(starchCode, flourCode)]
printTable(toPrint, params, workingDir)
})})
```

```{r, echo = FALSE}
suppressMessages({suppressWarnings({
params$elementPrefix = ""
invisible({
standTree = copy(tree)
standTree[, c(params$geoVar) := "840"]
standTree[, c(params$yearVar) := "2011"]
standTree[, share := 1]
## Don't standardize back germ and bran
standTree[parentID == "0111" & childID == "39120.01", extractionRate := Inf]
standTree[parentID == "0111" & childID == "23140.01", extractionRate := Inf]
})
params$elementPrefix = ""
finalValues = finalStandardizationToPrimary(data = sugarData, tree = standTree,
                                            standParams = params)
finalValues = finalValues[timePointYears == "2011", ]
printTable(finalValues, standParams = params, workingDir)
})})
```

We can also compute calories, fats, and proteins at this point.  First, we apply a calorie/fat/protein content factor to each individual element:

```{r, echo = FALSE}
suppressWarnings({suppressMessages({

load(paste0(workingDir, "nutrientData.RData"))
# Loads object "nutrientData"
    
toPrint = sugarData[timePointYears == "2011" & element == params$foodCode, ]
toPrint = merge(toPrint, nutrientData, by = params$itemVar, all.x = TRUE)

setnames(itemName, params$childVar, params$itemVar)
toPrint = merge(toPrint[, c(params$itemVar, "Value", "Protein", "Fat", "Energy"),
                        with = FALSE], itemName, all.x = TRUE)
setnames(itemName, params$itemVar, "Item")
toPrint[, measuredItemCPC := NULL]

setcolorder(toPrint, c("Name", "Value", "Energy", "Protein", "Fat"))
setnames(toPrint, "Value", "Quantity")
knitr::kable(toPrint)

})})
```

Standardization is trivial: all the commodities here are purely additive, so the standardized calories/fats/proteins are simply the sum of the total calories/fats/proteins for each element:

```{r, echo = FALSE}
out = toPrint[, list(
    Energy  = sum(Quantity * Energy , na.rm = TRUE)/1000000,
    Protein = sum(Quantity * Protein, na.rm = TRUE)/1000000,
    Fat     = sum(Quantity * Fat    , na.rm = TRUE)/1000000), by = ""]
out = round(out, 2)
setnames(out, colnames(out), paste(colnames(out), "(millions)"))
knitr::kable(out)
```


```{r, echo = FALSE}
rm(sugarData)
```